
input AcceptTopicSuggestionInput {
  clientMutationId: String

  name: String!

  repositoryId: ID!
}

type AcceptTopicSuggestionPayload {
  clientMutationId: String

  topic: Topic
}

interface Actor {
  avatarUrl(
    size: Int
  ): URI!

  login: String!

  resourcePath: URI!

  url: URI!
}

input AddAssigneesToAssignableInput {
  assignableId: ID!

  assigneeIds: [ID!]!

  clientMutationId: String
}

type AddAssigneesToAssignablePayload {
  assignable: Assignable

  clientMutationId: String
}

input AddCommentInput {
  body: String!

  clientMutationId: String

  subjectId: ID!
}

type AddCommentPayload {
  clientMutationId: String

  commentEdge: IssueCommentEdge

  subject: Node

  timelineEdge: IssueTimelineItemEdge
}

input AddLabelsToLabelableInput {
  clientMutationId: String

  labelIds: [ID!]!

  labelableId: ID!
}

type AddLabelsToLabelablePayload {
  clientMutationId: String

  labelable: Labelable
}

input AddProjectCardInput {
  clientMutationId: String

  contentId: ID

  note: String

  projectColumnId: ID!
}

type AddProjectCardPayload {
  cardEdge: ProjectCardEdge

  clientMutationId: String

  projectColumn: ProjectColumn
}

input AddProjectColumnInput {
  clientMutationId: String

  name: String!

  projectId: ID!
}

type AddProjectColumnPayload {
  clientMutationId: String

  columnEdge: ProjectColumnEdge

  project: Project
}

input AddPullRequestReviewCommentInput {
  body: String!

  clientMutationId: String

  commitOID: GitObjectID

  inReplyTo: ID

  path: String

  position: Int

  pullRequestReviewId: ID!
}

type AddPullRequestReviewCommentPayload {
  clientMutationId: String

  comment: PullRequestReviewComment

  commentEdge: PullRequestReviewCommentEdge
}

input AddPullRequestReviewInput {
  body: String

  clientMutationId: String

  comments: [DraftPullRequestReviewComment]

  commitOID: GitObjectID

  event: PullRequestReviewEvent

  pullRequestId: ID!
}

type AddPullRequestReviewPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview

  reviewEdge: PullRequestReviewEdge
}

input AddReactionInput {
  clientMutationId: String

  content: ReactionContent!

  subjectId: ID!
}

type AddReactionPayload {
  clientMutationId: String

  reaction: Reaction

  subject: Reactable
}

input AddStarInput {
  clientMutationId: String

  starrableId: ID!
}

type AddStarPayload {
  clientMutationId: String

  starrable: Starrable
}

type AddedToProjectEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

type App implements Node {
  createdAt: DateTime!

  databaseId: Int

  description: String
  id: ID!

  logoBackgroundColor: String!

  logoUrl(
    size: Int
  ): URI!

  name: String!

  slug: String!

  updatedAt: DateTime!

  url: URI!
}

type AppEdge {
  cursor: String!

  node: App
}

interface Assignable {
  assignees(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!
}

type AssignedEvent implements Node {
  actor: Actor

  assignable: Assignable!

  assignee: Assignee

  createdAt: DateTime!
  id: ID!

  user: User @deprecated(reason: "Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.")
}

union Assignee = Bot | Mannequin | Organization | User

type BaseRefChangedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

type BaseRefForcePushedEvent implements Node {
  actor: Actor

  afterCommit: Commit

  beforeCommit: Commit

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!

  ref: Ref
}

type Blame {
  ranges: [BlameRange!]!
}

type BlameRange {
  age: Int!

  commit: Commit!

  endingLine: Int!

  startingLine: Int!
}

type Blob implements GitObject & Node {
  abbreviatedOid: String!

  byteSize: Int!

  commitResourcePath: URI!

  commitUrl: URI!
  id: ID!

  isBinary: Boolean!

  isTruncated: Boolean!

  oid: GitObjectID!

  repository: Repository!

  text: String
}

type Bot implements Actor & Node & UniformResourceLocatable {
  avatarUrl(
    size: Int
  ): URI!

  createdAt: DateTime!

  databaseId: Int
  id: ID!

  login: String!

  resourcePath: URI!

  updatedAt: DateTime!

  url: URI!
}

type BranchProtectionRule implements Node {
  branchProtectionRuleConflicts(
    after: String

    before: String

    first: Int

    last: Int
  ): BranchProtectionRuleConflictConnection!

  creator: Actor

  databaseId: Int

  dismissesStaleReviews: Boolean!
  id: ID!

  isAdminEnforced: Boolean!

  matchingRefs(
    after: String

    before: String

    first: Int

    last: Int
  ): RefConnection!

  pattern: String!

  pushAllowances(
    after: String

    before: String

    first: Int

    last: Int
  ): PushAllowanceConnection!

  repository: Repository

  requiredApprovingReviewCount: Int

  requiredStatusCheckContexts: [String]

  requiresApprovingReviews: Boolean!

  requiresCodeOwnerReviews: Boolean!

  requiresCommitSignatures: Boolean!

  requiresStatusChecks: Boolean!

  requiresStrictStatusChecks: Boolean!

  restrictsPushes: Boolean!

  restrictsReviewDismissals: Boolean!

  reviewDismissalAllowances(
    after: String

    before: String

    first: Int

    last: Int
  ): ReviewDismissalAllowanceConnection!
}

type BranchProtectionRuleConflict {
  branchProtectionRule: BranchProtectionRule

  conflictingBranchProtectionRule: BranchProtectionRule

  ref: Ref
}

type BranchProtectionRuleConflictConnection {
  edges: [BranchProtectionRuleConflictEdge]

  nodes: [BranchProtectionRuleConflict]

  pageInfo: PageInfo!

  totalCount: Int!
}

type BranchProtectionRuleConflictEdge {
  cursor: String!

  node: BranchProtectionRuleConflict
}

type BranchProtectionRuleConnection {
  edges: [BranchProtectionRuleEdge]

  nodes: [BranchProtectionRule]

  pageInfo: PageInfo!

  totalCount: Int!
}

type BranchProtectionRuleEdge {
  cursor: String!

  node: BranchProtectionRule
}

input ChangeUserStatusInput {
  clientMutationId: String

  emoji: String

  expiresAt: DateTime

  limitedAvailability: Boolean = false

  message: String

  organizationId: ID
}

type ChangeUserStatusPayload {
  clientMutationId: String

  status: UserStatus
}

input ClearLabelsFromLabelableInput {
  clientMutationId: String

  labelableId: ID!
}

type ClearLabelsFromLabelablePayload {
  clientMutationId: String

  labelable: Labelable
}

input CloneProjectInput {
  body: String

  clientMutationId: String

  includeWorkflows: Boolean!

  name: String!

  public: Boolean

  sourceId: ID!

  targetOwnerId: ID!
}

type CloneProjectPayload {
  clientMutationId: String

  jobStatusId: String

  project: Project
}

input CloneTemplateRepositoryInput {
  clientMutationId: String

  description: String

  name: String!

  ownerId: ID!

  repositoryId: ID!

  visibility: RepositoryVisibility!
}

type CloneTemplateRepositoryPayload {
  clientMutationId: String

  repository: Repository
}

interface Closable {
  closed: Boolean!

  closedAt: DateTime
}

input CloseIssueInput {
  clientMutationId: String

  issueId: ID!
}

type CloseIssuePayload {
  clientMutationId: String

  issue: Issue
}

input ClosePullRequestInput {
  clientMutationId: String

  pullRequestId: ID!
}

type ClosePullRequestPayload {
  clientMutationId: String

  pullRequest: PullRequest
}

type ClosedEvent implements Node & UniformResourceLocatable {
  actor: Actor

  closable: Closable!

  closer: Closer

  createdAt: DateTime!
  id: ID!

  resourcePath: URI!

  url: URI!
}

union Closer = Commit | PullRequest

type CodeOfConduct implements Node {
  body: String
  id: ID!

  key: String!

  name: String!

  resourcePath: URI

  url: URI
}

enum CollaboratorAffiliation {
  ALL

  DIRECT

  OUTSIDE
}

union CollectionItemContent = Organization | Repository | User

interface Comment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  lastEditedAt: DateTime

  publishedAt: DateTime

  updatedAt: DateTime!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerDidAuthor: Boolean!
}

enum CommentAuthorAssociation {
  COLLABORATOR

  CONTRIBUTOR

  FIRST_TIMER

  FIRST_TIME_CONTRIBUTOR

  MEMBER

  NONE

  OWNER
}

enum CommentCannotUpdateReason {
  DENIED

  INSUFFICIENT_ACCESS

  LOCKED

  LOGIN_REQUIRED

  MAINTENANCE

  VERIFIED_EMAIL_REQUIRED
}

type CommentDeletedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

type Commit implements GitObject & Node & Subscribable & UniformResourceLocatable {
  abbreviatedOid: String!

  additions: Int!

  associatedPullRequests(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: PullRequestOrder = {field: CREATED_AT, direction: ASC}
  ): PullRequestConnection

  author: GitActor

  authoredByCommitter: Boolean!

  authoredDate: DateTime!

  blame(
    path: String!
  ): Blame!

  changedFiles: Int!

  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitCommentConnection!

  commitResourcePath: URI!

  commitUrl: URI!

  committedDate: DateTime!

  committedViaWeb: Boolean!

  committer: GitActor

  deletions: Int!

  deployments(
    after: String

    before: String

    environments: [String!]

    first: Int

    last: Int

    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection

  history(
    after: String

    author: CommitAuthor

    before: String

    first: Int

    last: Int

    path: String

    since: GitTimestamp

    until: GitTimestamp
  ): CommitHistoryConnection!
  id: ID!

  message: String!

  messageBody: String!

  messageBodyHTML: HTML!

  messageHeadline: String!

  messageHeadlineHTML: HTML!

  oid: GitObjectID!

  parents(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitConnection!

  pushedDate: DateTime

  repository: Repository!

  resourcePath: URI!

  signature: GitSignature

  status: Status

  tarballUrl: URI!

  tree: Tree!

  treeResourcePath: URI!

  treeUrl: URI!

  url: URI!

  viewerCanSubscribe: Boolean!

  viewerSubscription: SubscriptionState

  zipballUrl: URI!
}

input CommitAuthor {
  emails: [String!]

  id: ID
}

type CommitComment implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  commit: Commit

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  isMinimized: Boolean!

  lastEditedAt: DateTime

  minimizedReason: String

  path: String

  position: Int

  publishedAt: DateTime

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  repository: Repository!

  resourcePath: URI!

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanDelete: Boolean!

  viewerCanMinimize: Boolean!

  viewerCanReact: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!
}

type CommitCommentConnection {
  edges: [CommitCommentEdge]

  nodes: [CommitComment]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CommitCommentEdge {
  cursor: String!

  node: CommitComment
}

type CommitCommentThread implements Node & RepositoryNode {
  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitCommentConnection!

  commit: Commit!
  id: ID!

  path: String

  position: Int

  repository: Repository!
}

type CommitConnection {
  edges: [CommitEdge]

  nodes: [Commit]

  pageInfo: PageInfo!

  totalCount: Int!
}

input CommitContributionOrder {
  direction: OrderDirection!

  field: CommitContributionOrderField!
}

enum CommitContributionOrderField {
  COMMIT_COUNT

  OCCURRED_AT
}

type CommitContributionsByRepository {
  contributions(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: CommitContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedCommitContributionConnection!

  repository: Repository!

  resourcePath: URI!

  url: URI!
}

type CommitEdge {
  cursor: String!

  node: Commit
}

type CommitHistoryConnection {
  edges: [CommitEdge]

  nodes: [Commit]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ContentAttachment {
  body: String!

  contentReference: ContentReference!

  databaseId: Int!
  id: ID!

  title: String!
}

type ContentReference {
  databaseId: Int!
  id: ID!

  reference: String!
}

interface Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  resourcePath: URI!

  url: URI!

  user: User!
}

type ContributionCalendar {
  colors: [String!]!

  isHalloween: Boolean!

  months: [ContributionCalendarMonth!]!

  totalContributions: Int!

  weeks: [ContributionCalendarWeek!]!
}

type ContributionCalendarDay {
  color: String!

  contributionCount: Int!

  date: Date!

  weekday: Int!
}

type ContributionCalendarMonth {
  firstDay: Date!

  name: String!

  totalWeeks: Int!

  year: Int!
}

type ContributionCalendarWeek {
  contributionDays: [ContributionCalendarDay!]!

  firstDay: Date!
}

input ContributionOrder {
  direction: OrderDirection!

  field: ContributionOrderField
}

enum ContributionOrderField {
  OCCURRED_AT
}

type ContributionsCollection {
  commitContributionsByRepository(
    maxRepositories: Int = 25
  ): [CommitContributionsByRepository!]!

  contributionCalendar: ContributionCalendar!

  contributionYears: [Int!]!

  doesEndInCurrentMonth: Boolean!

  earliestRestrictedContributionDate: Date

  endedAt: DateTime!

  firstIssueContribution: CreatedIssueOrRestrictedContribution

  firstPullRequestContribution: CreatedPullRequestOrRestrictedContribution

  firstRepositoryContribution: CreatedRepositoryOrRestrictedContribution

  hasActivityInThePast: Boolean!

  hasAnyContributions: Boolean!

  hasAnyRestrictedContributions: Boolean!

  isSingleDay: Boolean!

  issueContributions(
    after: String

    before: String

    excludeFirst: Boolean = false

    excludePopular: Boolean = false

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedIssueContributionConnection!

  issueContributionsByRepository(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false

    maxRepositories: Int = 25
  ): [IssueContributionsByRepository!]!

  joinedGitHubContribution: JoinedGitHubContribution

  latestRestrictedContributionDate: Date

  mostRecentCollectionWithActivity: ContributionsCollection

  mostRecentCollectionWithoutActivity: ContributionsCollection

  popularIssueContribution: CreatedIssueContribution

  popularPullRequestContribution: CreatedPullRequestContribution

  pullRequestContributions(
    after: String

    before: String

    excludeFirst: Boolean = false

    excludePopular: Boolean = false

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedPullRequestContributionConnection!

  pullRequestContributionsByRepository(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false

    maxRepositories: Int = 25
  ): [PullRequestContributionsByRepository!]!

  pullRequestReviewContributions(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!

  pullRequestReviewContributionsByRepository(
    maxRepositories: Int = 25
  ): [PullRequestReviewContributionsByRepository!]!

  repositoryContributions(
    after: String

    before: String

    excludeFirst: Boolean = false

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedRepositoryContributionConnection!

  restrictedContributionsCount: Int!

  startedAt: DateTime!

  totalCommitContributions: Int!

  totalIssueContributions(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false
  ): Int!

  totalPullRequestContributions(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false
  ): Int!

  totalPullRequestReviewContributions: Int!

  totalRepositoriesWithContributedCommits: Int!

  totalRepositoriesWithContributedIssues(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false
  ): Int!

  totalRepositoriesWithContributedPullRequestReviews: Int!

  totalRepositoriesWithContributedPullRequests(
    excludeFirst: Boolean = false

    excludePopular: Boolean = false
  ): Int!

  totalRepositoryContributions(
    excludeFirst: Boolean = false
  ): Int!

  user: User!
}

input ConvertProjectCardNoteToIssueInput {
  body: String

  clientMutationId: String

  projectCardId: ID!

  repositoryId: ID!

  title: String
}

type ConvertProjectCardNoteToIssuePayload {
  clientMutationId: String

  projectCard: ProjectCard
}

type ConvertedNoteToIssueEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

input CreateBranchProtectionRuleInput {
  clientMutationId: String

  dismissesStaleReviews: Boolean

  isAdminEnforced: Boolean

  pattern: String!

  pushActorIds: [ID!]

  repositoryId: ID!

  requiredApprovingReviewCount: Int

  requiredStatusCheckContexts: [String!]

  requiresApprovingReviews: Boolean

  requiresCodeOwnerReviews: Boolean

  requiresCommitSignatures: Boolean

  requiresStatusChecks: Boolean

  requiresStrictStatusChecks: Boolean

  restrictsPushes: Boolean

  restrictsReviewDismissals: Boolean

  reviewDismissalActorIds: [ID!]
}

type CreateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule

  clientMutationId: String
}

input CreateContentAttachmentInput {
  body: String!

  clientMutationId: String

  contentReferenceId: ID!

  title: String!
}

input CreateIssueInput {
  assigneeIds: [ID!]

  body: String

  clientMutationId: String

  labelIds: [ID!]

  milestoneId: ID

  projectIds: [ID!]

  repositoryId: ID!

  title: String!
}

type CreateIssuePayload {
  clientMutationId: String

  issue: Issue
}

input CreateProjectInput {
  body: String

  clientMutationId: String

  name: String!

  ownerId: ID!

  repositoryIds: [ID!]

  template: ProjectTemplate
}

type CreateProjectPayload {
  clientMutationId: String

  project: Project
}

input CreatePullRequestInput {
  baseRefName: String!

  body: String

  clientMutationId: String

  headRefName: String!

  maintainerCanModify: Boolean = true

  repositoryId: ID!

  title: String!
}

type CreatePullRequestPayload {
  clientMutationId: String

  pullRequest: PullRequest
}

input CreateRefInput {
  clientMutationId: String

  name: String!

  oid: GitObjectID!

  repositoryId: ID!
}

type CreateRefPayload {
  clientMutationId: String

  ref: Ref
}

input CreateRepositoryInput {
  clientMutationId: String

  description: String

  hasIssuesEnabled: Boolean = true

  hasWikiEnabled: Boolean = false

  homepageUrl: URI

  name: String!

  ownerId: ID

  teamId: ID

  template: Boolean = false

  visibility: RepositoryVisibility!
}

type CreateRepositoryPayload {
  clientMutationId: String

  repository: Repository
}

type CreatedCommitContribution implements Contribution {
  commitCount: Int!

  isRestricted: Boolean!

  occurredAt: DateTime!

  repository: Repository!

  resourcePath: URI!

  url: URI!

  user: User!
}

type CreatedCommitContributionConnection {
  edges: [CreatedCommitContributionEdge]

  nodes: [CreatedCommitContribution]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CreatedCommitContributionEdge {
  cursor: String!

  node: CreatedCommitContribution
}

type CreatedIssueContribution implements Contribution {
  isRestricted: Boolean!

  issue: Issue!

  occurredAt: DateTime!

  resourcePath: URI!

  url: URI!

  user: User!
}

type CreatedIssueContributionConnection {
  edges: [CreatedIssueContributionEdge]

  nodes: [CreatedIssueContribution]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CreatedIssueContributionEdge {
  cursor: String!

  node: CreatedIssueContribution
}

union CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution

type CreatedPullRequestContribution implements Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  pullRequest: PullRequest!

  resourcePath: URI!

  url: URI!

  user: User!
}

type CreatedPullRequestContributionConnection {
  edges: [CreatedPullRequestContributionEdge]

  nodes: [CreatedPullRequestContribution]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CreatedPullRequestContributionEdge {
  cursor: String!

  node: CreatedPullRequestContribution
}

union CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution

type CreatedPullRequestReviewContribution implements Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  pullRequest: PullRequest!

  pullRequestReview: PullRequestReview!

  repository: Repository!

  resourcePath: URI!

  url: URI!

  user: User!
}

type CreatedPullRequestReviewContributionConnection {
  edges: [CreatedPullRequestReviewContributionEdge]

  nodes: [CreatedPullRequestReviewContribution]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CreatedPullRequestReviewContributionEdge {
  cursor: String!

  node: CreatedPullRequestReviewContribution
}

type CreatedRepositoryContribution implements Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  repository: Repository!

  resourcePath: URI!

  url: URI!

  user: User!
}

type CreatedRepositoryContributionConnection {
  edges: [CreatedRepositoryContributionEdge]

  nodes: [CreatedRepositoryContribution]

  pageInfo: PageInfo!

  totalCount: Int!
}

type CreatedRepositoryContributionEdge {
  cursor: String!

  node: CreatedRepositoryContribution
}

union CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution

type CrossReferencedEvent implements Node & UniformResourceLocatable {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  isCrossRepository: Boolean!

  referencedAt: DateTime!

  resourcePath: URI!

  source: ReferencedSubject!

  target: ReferencedSubject!

  url: URI!

  willCloseTarget: Boolean!
}

scalar Date

scalar DateTime

input DeclineTopicSuggestionInput {
  clientMutationId: String

  name: String!

  reason: TopicSuggestionDeclineReason!

  repositoryId: ID!
}

type DeclineTopicSuggestionPayload {
  clientMutationId: String

  topic: Topic
}

enum DefaultRepositoryPermissionField {
  ADMIN

  NONE

  READ

  WRITE
}

interface Deletable {
  viewerCanDelete: Boolean!
}

input DeleteBranchProtectionRuleInput {
  branchProtectionRuleId: ID!

  clientMutationId: String
}

type DeleteBranchProtectionRulePayload {
  clientMutationId: String
}

input DeleteIssueCommentInput {
  clientMutationId: String

  id: ID!
}

type DeleteIssueCommentPayload {
  clientMutationId: String
}

input DeleteIssueInput {
  clientMutationId: String

  issueId: ID!
}

type DeleteIssuePayload {
  clientMutationId: String

  repository: Repository
}

input DeleteProjectCardInput {
  cardId: ID!

  clientMutationId: String
}

type DeleteProjectCardPayload {
  clientMutationId: String

  column: ProjectColumn

  deletedCardId: ID
}

input DeleteProjectColumnInput {
  clientMutationId: String

  columnId: ID!
}

type DeleteProjectColumnPayload {
  clientMutationId: String

  deletedColumnId: ID

  project: Project
}

input DeleteProjectInput {
  clientMutationId: String

  projectId: ID!
}

type DeleteProjectPayload {
  clientMutationId: String

  owner: ProjectOwner
}

input DeletePullRequestReviewCommentInput {
  clientMutationId: String

  id: ID!
}

type DeletePullRequestReviewCommentPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview
}

input DeletePullRequestReviewInput {
  clientMutationId: String

  pullRequestReviewId: ID!
}

type DeletePullRequestReviewPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview
}

input DeleteRefInput {
  clientMutationId: String

  refId: ID!
}

type DeleteRefPayload {
  clientMutationId: String
}

type DemilestonedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  milestoneTitle: String!

  subject: MilestoneItem!
}

type DeployKey implements Node {
  createdAt: DateTime!
  id: ID!

  key: String!

  readOnly: Boolean!

  title: String!

  verified: Boolean!
}

type DeployKeyConnection {
  edges: [DeployKeyEdge]

  nodes: [DeployKey]

  pageInfo: PageInfo!

  totalCount: Int!
}

type DeployKeyEdge {
  cursor: String!

  node: DeployKey
}

type DeployedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int

  deployment: Deployment!
  id: ID!

  pullRequest: PullRequest!

  ref: Ref
}

type Deployment implements Node {
  commit: Commit

  commitOid: String!

  createdAt: DateTime!

  creator: Actor

  databaseId: Int

  description: String

  environment: String
  id: ID!

  latestStatus: DeploymentStatus

  payload: String

  ref: Ref

  repository: Repository!

  state: DeploymentState

  statuses(
    after: String

    before: String

    first: Int

    last: Int
  ): DeploymentStatusConnection

  task: String

  updatedAt: DateTime!
}

type DeploymentConnection {
  edges: [DeploymentEdge]

  nodes: [Deployment]

  pageInfo: PageInfo!

  totalCount: Int!
}

type DeploymentEdge {
  cursor: String!

  node: Deployment
}

type DeploymentEnvironmentChangedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  deploymentStatus: DeploymentStatus!
  id: ID!

  pullRequest: PullRequest!
}

input DeploymentOrder {
  direction: OrderDirection!

  field: DeploymentOrderField!
}

enum DeploymentOrderField {
  CREATED_AT
}

enum DeploymentState {
  ABANDONED

  ACTIVE

  DESTROYED

  ERROR

  FAILURE

  INACTIVE

  IN_PROGRESS

  PENDING

  QUEUED
}

type DeploymentStatus implements Node {
  createdAt: DateTime!

  creator: Actor

  deployment: Deployment!

  description: String

  environmentUrl: URI
  id: ID!

  logUrl: URI

  state: DeploymentStatusState!

  updatedAt: DateTime!
}

type DeploymentStatusConnection {
  edges: [DeploymentStatusEdge]

  nodes: [DeploymentStatus]

  pageInfo: PageInfo!

  totalCount: Int!
}

type DeploymentStatusEdge {
  cursor: String!

  node: DeploymentStatus
}

enum DeploymentStatusState {
  ERROR

  FAILURE

  INACTIVE

  IN_PROGRESS

  PENDING

  QUEUED

  SUCCESS
}

input DismissPullRequestReviewInput {
  clientMutationId: String

  message: String!

  pullRequestReviewId: ID!
}

type DismissPullRequestReviewPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview
}

input DraftPullRequestReviewComment {
  body: String!

  path: String!

  position: Int!
}

type ExternalIdentity implements Node {
  guid: String!
  id: ID!

  organizationInvitation: OrganizationInvitation

  samlIdentity: ExternalIdentitySamlAttributes

  scimIdentity: ExternalIdentityScimAttributes

  user: User
}

type ExternalIdentityConnection {
  edges: [ExternalIdentityEdge]

  nodes: [ExternalIdentity]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ExternalIdentityEdge {
  cursor: String!

  node: ExternalIdentity
}

type ExternalIdentitySamlAttributes {
  nameId: String
}

type ExternalIdentityScimAttributes {
  username: String
}

type FollowerConnection {
  edges: [UserEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type FollowingConnection {
  edges: [UserEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type Gist implements Node & Starrable & UniformResourceLocatable {
  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): GistCommentConnection!

  createdAt: DateTime!

  description: String

  files(
    limit: Int = 10

    oid: GitObjectID
  ): [GistFile]

  forks(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: GistOrder
  ): GistConnection!
  id: ID!

  isFork: Boolean!

  isPublic: Boolean!

  name: String!

  owner: RepositoryOwner

  pushedAt: DateTime

  resourcePath: URI!

  stargazers(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: StarOrder
  ): StargazerConnection!

  updatedAt: DateTime!

  url: URI!

  viewerHasStarred: Boolean!
}

type GistComment implements Comment & Deletable & Node & Updatable & UpdatableComment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  editor: Actor

  gist: Gist!
  id: ID!

  includesCreatedEdit: Boolean!

  isMinimized: Boolean!

  lastEditedAt: DateTime

  minimizedReason: String

  publishedAt: DateTime

  updatedAt: DateTime!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanDelete: Boolean!

  viewerCanMinimize: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!
}

type GistCommentConnection {
  edges: [GistCommentEdge]

  nodes: [GistComment]

  pageInfo: PageInfo!

  totalCount: Int!
}

type GistCommentEdge {
  cursor: String!

  node: GistComment
}

type GistConnection {
  edges: [GistEdge]

  nodes: [Gist]

  pageInfo: PageInfo!

  totalCount: Int!
}

type GistEdge {
  cursor: String!

  node: Gist
}

type GistFile {
  encodedName: String

  encoding: String

  extension: String

  isImage: Boolean!

  isTruncated: Boolean!

  language: Language

  name: String

  size: Int

  text(
    truncate: Int
  ): String
}

input GistOrder {
  direction: OrderDirection!

  field: GistOrderField!
}

enum GistOrderField {
  CREATED_AT

  PUSHED_AT

  UPDATED_AT
}

enum GistPrivacy {
  ALL

  PUBLIC

  SECRET
}

type GitActor {
  avatarUrl(
    size: Int
  ): URI!

  date: GitTimestamp

  email: String

  name: String

  user: User
}

type GitHubMetadata {
  gitHubServicesSha: GitObjectID!

  gitIpAddresses: [String!]

  hookIpAddresses: [String!]

  importerIpAddresses: [String!]

  isPasswordAuthenticationVerifiable: Boolean!

  pagesIpAddresses: [String!]
}

interface GitObject {
  abbreviatedOid: String!

  commitResourcePath: URI!

  commitUrl: URI!
  id: ID!

  oid: GitObjectID!

  repository: Repository!
}

scalar GitObjectID

scalar GitSSHRemote

interface GitSignature {
  email: String!

  isValid: Boolean!

  payload: String!

  signature: String!

  signer: User

  state: GitSignatureState!

  wasSignedByGitHub: Boolean!
}

enum GitSignatureState {
  BAD_CERT

  BAD_EMAIL

  EXPIRED_KEY

  GPGVERIFY_ERROR

  GPGVERIFY_UNAVAILABLE

  INVALID

  MALFORMED_SIG

  NOT_SIGNING_KEY

  NO_USER

  OCSP_ERROR

  OCSP_PENDING

  OCSP_REVOKED

  UNKNOWN_KEY

  UNKNOWN_SIG_TYPE

  UNSIGNED

  UNVERIFIED_EMAIL

  VALID
}

scalar GitTimestamp

type GpgSignature implements GitSignature {
  email: String!

  isValid: Boolean!

  keyId: String

  payload: String!

  signature: String!

  signer: User

  state: GitSignatureState!

  wasSignedByGitHub: Boolean!
}

scalar HTML

type HeadRefDeletedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  headRef: Ref

  headRefName: String!
  id: ID!

  pullRequest: PullRequest!
}

type HeadRefForcePushedEvent implements Node {
  actor: Actor

  afterCommit: Commit

  beforeCommit: Commit

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!

  ref: Ref
}

type HeadRefRestoredEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!
}

enum IdentityProviderConfigurationState {
  CONFIGURED

  ENFORCED

  UNCONFIGURED
}

input ImportProjectInput {
  body: String

  clientMutationId: String

  columnImports: [ProjectColumnImport!]!

  name: String!

  ownerName: String!

  public: Boolean = false
}

type Issue implements Assignable & Closable & Comment & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason

  assignees(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  closed: Boolean!

  closedAt: DateTime

  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): IssueCommentConnection!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  labels(
    after: String

    before: String

    first: Int

    last: Int
  ): LabelConnection

  lastEditedAt: DateTime

  locked: Boolean!

  milestone: Milestone

  number: Int!

  participants(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  projectCards(
    after: String

    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]

    before: String

    first: Int

    last: Int
  ): ProjectCardConnection!

  publishedAt: DateTime

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  repository: Repository!

  resourcePath: URI!

  state: IssueState!

  timeline(
    after: String

    before: String

    first: Int

    last: Int

    since: DateTime
  ): IssueTimelineConnection! @deprecated(reason: "`timeline` will be removed Use Issue.timelineItems instead. Removal on 2019-10-01 UTC.")

  timelineItems(
    after: String

    before: String

    first: Int

    itemTypes: [IssueTimelineItemsItemType!]

    last: Int

    since: DateTime

    skip: Int
  ): IssueTimelineItemsConnection!

  title: String!

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanReact: Boolean!

  viewerCanSubscribe: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!

  viewerSubscription: SubscriptionState
}

type IssueComment implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  isMinimized: Boolean!

  issue: Issue!

  lastEditedAt: DateTime

  minimizedReason: String

  publishedAt: DateTime

  pullRequest: PullRequest

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  repository: Repository!

  resourcePath: URI!

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanDelete: Boolean!

  viewerCanMinimize: Boolean!

  viewerCanReact: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!
}

type IssueCommentConnection {
  edges: [IssueCommentEdge]

  nodes: [IssueComment]

  pageInfo: PageInfo!

  totalCount: Int!
}

type IssueCommentEdge {
  cursor: String!

  node: IssueComment
}

type IssueConnection {
  edges: [IssueEdge]

  nodes: [Issue]

  pageInfo: PageInfo!

  totalCount: Int!
}

type IssueContributionsByRepository {
  contributions(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedIssueContributionConnection!

  repository: Repository!
}

type IssueEdge {
  cursor: String!

  node: Issue
}

input IssueFilters {
  assignee: String

  createdBy: String

  labels: [String!]

  mentioned: String

  milestone: String

  since: DateTime

  states: [IssueState!]

  viewerSubscribed: Boolean = false
}

union IssueOrPullRequest = Issue | PullRequest

type IssueOrPullRequestEdge {
  cursor: String!

  node: IssueOrPullRequest
}

input IssueOrder {
  direction: OrderDirection!

  field: IssueOrderField!
}

enum IssueOrderField {
  COMMENTS

  CREATED_AT

  UPDATED_AT
}

enum IssuePubSubTopic {
  MARKASREAD

  STATE

  TIMELINE

  UPDATED
}

enum IssueState {
  CLOSED

  OPEN
}

type IssueTimelineConnection {
  edges: [IssueTimelineItemEdge]

  nodes: [IssueTimelineItem]

  pageInfo: PageInfo!

  totalCount: Int!
}

union IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent

type IssueTimelineItemEdge {
  cursor: String!

  node: IssueTimelineItem
}

union IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConvertedNoteToIssueEvent | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent

type IssueTimelineItemsConnection {
  edges: [IssueTimelineItemsEdge]

  filteredCount: Int!

  nodes: [IssueTimelineItems]

  pageCount: Int!

  pageInfo: PageInfo!

  totalCount: Int!

  updatedAt: DateTime!
}

type IssueTimelineItemsEdge {
  cursor: String!

  node: IssueTimelineItems
}

enum IssueTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT

  ASSIGNED_EVENT

  CLOSED_EVENT

  COMMENT_DELETED_EVENT

  CONVERTED_NOTE_TO_ISSUE_EVENT

  CROSS_REFERENCED_EVENT

  DEMILESTONED_EVENT

  ISSUE_COMMENT

  LABELED_EVENT

  LOCKED_EVENT

  MARKED_AS_DUPLICATE_EVENT

  MENTIONED_EVENT

  MILESTONED_EVENT

  MOVED_COLUMNS_IN_PROJECT_EVENT

  PINNED_EVENT

  REFERENCED_EVENT

  REMOVED_FROM_PROJECT_EVENT

  RENAMED_TITLE_EVENT

  REOPENED_EVENT

  SUBSCRIBED_EVENT

  TRANSFERRED_EVENT

  UNASSIGNED_EVENT

  UNLABELED_EVENT

  UNLOCKED_EVENT

  UNPINNED_EVENT

  UNSUBSCRIBED_EVENT

  USER_BLOCKED_EVENT
}

type JoinedGitHubContribution implements Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  resourcePath: URI!

  url: URI!

  user: User!
}

type Label implements Node {
  color: String!

  createdAt: DateTime

  description: String
  id: ID!

  isDefault: Boolean!

  issues(
    after: String

    before: String

    filterBy: IssueFilters

    first: Int

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [IssueState!]
  ): IssueConnection!

  name: String!

  pullRequests(
    after: String

    baseRefName: String

    before: String

    first: Int

    headRefName: String

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [PullRequestState!]
  ): PullRequestConnection!

  repository: Repository!

  resourcePath: URI!

  updatedAt: DateTime

  url: URI!
}

type LabelConnection {
  edges: [LabelEdge]

  nodes: [Label]

  pageInfo: PageInfo!

  totalCount: Int!
}

type LabelEdge {
  cursor: String!

  node: Label
}

interface Labelable {
  labels(
    after: String

    before: String

    first: Int

    last: Int
  ): LabelConnection
}

type LabeledEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  label: Label!

  labelable: Labelable!
}

type Language implements Node {
  color: String
  id: ID!

  name: String!
}

type LanguageConnection {
  edges: [LanguageEdge]

  nodes: [Language]

  pageInfo: PageInfo!

  totalCount: Int!

  totalSize: Int!
}

type LanguageEdge {
  cursor: String!
  node: Language!

  size: Int!
}

input LanguageOrder {
  direction: OrderDirection!

  field: LanguageOrderField!
}

enum LanguageOrderField {
  SIZE
}

type License implements Node {
  body: String!

  conditions: [LicenseRule]!

  description: String

  featured: Boolean!

  hidden: Boolean!
  id: ID!

  implementation: String

  key: String!

  limitations: [LicenseRule]!

  name: String!

  nickname: String

  permissions: [LicenseRule]!

  pseudoLicense: Boolean!

  spdxId: String

  url: URI
}

type LicenseRule {
  description: String!

  key: String!

  label: String!
}

input LinkRepositoryToProjectInput {
  clientMutationId: String

  projectId: ID!

  repositoryId: ID!
}

type LinkRepositoryToProjectPayload {
  clientMutationId: String

  project: Project

  repository: Repository
}

input LockLockableInput {
  clientMutationId: String

  lockReason: LockReason

  lockableId: ID!
}

type LockLockablePayload {
  clientMutationId: String

  lockedRecord: Lockable
}

enum LockReason {
  OFF_TOPIC

  RESOLVED

  SPAM

  TOO_HEATED
}

interface Lockable {
  activeLockReason: LockReason

  locked: Boolean!
}

type LockedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  lockReason: LockReason

  lockable: Lockable!
}

type Mannequin implements Actor & Node & UniformResourceLocatable {
  avatarUrl(
    size: Int
  ): URI!

  createdAt: DateTime!

  databaseId: Int
  id: ID!

  login: String!

  resourcePath: URI!

  updatedAt: DateTime!

  url: URI!
}

type MarkedAsDuplicateEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!
}

type MarketplaceCategory implements Node {
  description: String

  howItWorks: String
  id: ID!

  name: String!

  primaryListingCount: Int!

  resourcePath: URI!

  secondaryListingCount: Int!

  slug: String!

  url: URI!
}

type MarketplaceListing implements Node {
  app: App

  companyUrl: URI

  configurationResourcePath: URI!

  configurationUrl: URI!

  documentationUrl: URI

  extendedDescription: String

  extendedDescriptionHTML: HTML!

  fullDescription: String!

  fullDescriptionHTML: HTML!

  hasApprovalBeenRequested: Boolean! @deprecated(reason: "`hasApprovalBeenRequested` will be removed. Use `isVerificationPendingFromDraft` instead. Removal on 2019-10-01 UTC.")

  hasPublishedFreeTrialPlans: Boolean!

  hasTermsOfService: Boolean!

  howItWorks: String

  howItWorksHTML: HTML!
  id: ID!

  installationUrl: URI

  installedForViewer: Boolean!

  isApproved: Boolean! @deprecated(reason: "`isApproved` will be removed. Use `isPublic` instead. Removal on 2019-10-01 UTC.")

  isArchived: Boolean!

  isDelisted: Boolean! @deprecated(reason: "`isDelisted` will be removed. Use `isArchived` instead. Removal on 2019-10-01 UTC.")

  isDraft: Boolean!

  isPaid: Boolean!

  isPublic: Boolean!

  isRejected: Boolean!

  isUnverified: Boolean!

  isUnverifiedPending: Boolean!

  isVerificationPendingFromDraft: Boolean!

  isVerificationPendingFromUnverified: Boolean!

  isVerified: Boolean!

  logoBackgroundColor: String!

  logoUrl(
    size: Int = 400
  ): URI

  name: String!

  normalizedShortDescription: String!

  pricingUrl: URI

  primaryCategory: MarketplaceCategory!

  privacyPolicyUrl: URI!

  resourcePath: URI!

  screenshotUrls: [String]!

  secondaryCategory: MarketplaceCategory

  shortDescription: String!

  slug: String!

  statusUrl: URI

  supportEmail: String

  supportUrl: URI!

  termsOfServiceUrl: URI

  url: URI!

  viewerCanAddPlans: Boolean!

  viewerCanApprove: Boolean!

  viewerCanDelist: Boolean!

  viewerCanEdit: Boolean!

  viewerCanEditCategories: Boolean!

  viewerCanEditPlans: Boolean!

  viewerCanRedraft: Boolean!

  viewerCanReject: Boolean!

  viewerCanRequestApproval: Boolean!

  viewerHasPurchased: Boolean!

  viewerHasPurchasedForAllOrganizations: Boolean!

  viewerIsListingAdmin: Boolean!
}

type MarketplaceListingConnection {
  edges: [MarketplaceListingEdge]

  nodes: [MarketplaceListing]

  pageInfo: PageInfo!

  totalCount: Int!
}

type MarketplaceListingEdge {
  cursor: String!

  node: MarketplaceListing
}

interface MemberStatusable {
  memberStatuses(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
}

type MentionedEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

input MergeBranchInput {
  base: String!

  clientMutationId: String

  commitMessage: String

  head: String!

  repositoryId: ID!
}

type MergeBranchPayload {
  clientMutationId: String

  mergeCommit: Commit
}

input MergePullRequestInput {
  clientMutationId: String

  commitBody: String

  commitHeadline: String

  expectedHeadOid: GitObjectID

  pullRequestId: ID!
}

type MergePullRequestPayload {
  clientMutationId: String

  pullRequest: PullRequest
}

enum MergeableState {
  CONFLICTING

  MERGEABLE

  UNKNOWN
}

type MergedEvent implements Node & UniformResourceLocatable {
  actor: Actor

  commit: Commit

  createdAt: DateTime!
  id: ID!

  mergeRef: Ref

  mergeRefName: String!

  pullRequest: PullRequest!

  resourcePath: URI!

  url: URI!
}

type Milestone implements Closable & Node & UniformResourceLocatable {
  closed: Boolean!

  closedAt: DateTime

  createdAt: DateTime!

  creator: Actor

  description: String

  dueOn: DateTime
  id: ID!

  issuePrioritiesDebug: String!

  issues(
    after: String

    before: String

    filterBy: IssueFilters

    first: Int

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [IssueState!]
  ): IssueConnection!

  number: Int!

  pullRequests(
    after: String

    baseRefName: String

    before: String

    first: Int

    headRefName: String

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [PullRequestState!]
  ): PullRequestConnection!

  repository: Repository!

  resourcePath: URI!

  state: MilestoneState!

  title: String!

  updatedAt: DateTime!

  url: URI!
}

type MilestoneConnection {
  edges: [MilestoneEdge]

  nodes: [Milestone]

  pageInfo: PageInfo!

  totalCount: Int!
}

type MilestoneEdge {
  cursor: String!

  node: Milestone
}

union MilestoneItem = Issue | PullRequest

input MilestoneOrder {
  direction: OrderDirection!

  field: MilestoneOrderField!
}

enum MilestoneOrderField {
  CREATED_AT

  DUE_DATE

  NUMBER

  UPDATED_AT
}

enum MilestoneState {
  CLOSED

  OPEN
}

type MilestonedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  milestoneTitle: String!

  subject: MilestoneItem!
}

input MinimizeCommentInput {
  classifier: ReportedContentClassifiers!

  clientMutationId: String

  subjectId: ID!
}

input MoveProjectCardInput {
  afterCardId: ID

  cardId: ID!

  clientMutationId: String

  columnId: ID!
}

type MoveProjectCardPayload {
  cardEdge: ProjectCardEdge

  clientMutationId: String
}

input MoveProjectColumnInput {
  afterColumnId: ID

  clientMutationId: String

  columnId: ID!
}

type MoveProjectColumnPayload {
  clientMutationId: String

  columnEdge: ProjectColumnEdge
}

type MovedColumnsInProjectEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

type Mutation {
  acceptTopicSuggestion(input: AcceptTopicSuggestionInput!): AcceptTopicSuggestionPayload

  addAssigneesToAssignable(input: AddAssigneesToAssignableInput!): AddAssigneesToAssignablePayload

  addComment(input: AddCommentInput!): AddCommentPayload

  addLabelsToLabelable(input: AddLabelsToLabelableInput!): AddLabelsToLabelablePayload

  addProjectCard(input: AddProjectCardInput!): AddProjectCardPayload

  addProjectColumn(input: AddProjectColumnInput!): AddProjectColumnPayload

  addPullRequestReview(input: AddPullRequestReviewInput!): AddPullRequestReviewPayload

  addPullRequestReviewComment(input: AddPullRequestReviewCommentInput!): AddPullRequestReviewCommentPayload

  addReaction(input: AddReactionInput!): AddReactionPayload

  addStar(input: AddStarInput!): AddStarPayload

  changeUserStatus(input: ChangeUserStatusInput!): ChangeUserStatusPayload

  clearLabelsFromLabelable(input: ClearLabelsFromLabelableInput!): ClearLabelsFromLabelablePayload

  cloneProject(input: CloneProjectInput!): CloneProjectPayload

  cloneTemplateRepository(input: CloneTemplateRepositoryInput!): CloneTemplateRepositoryPayload

  closeIssue(input: CloseIssueInput!): CloseIssuePayload

  closePullRequest(input: ClosePullRequestInput!): ClosePullRequestPayload

  convertProjectCardNoteToIssue(input: ConvertProjectCardNoteToIssueInput!): ConvertProjectCardNoteToIssuePayload

  createBranchProtectionRule(input: CreateBranchProtectionRuleInput!): CreateBranchProtectionRulePayload

  createIssue(input: CreateIssueInput!): CreateIssuePayload

  createProject(input: CreateProjectInput!): CreateProjectPayload

  createPullRequest(input: CreatePullRequestInput!): CreatePullRequestPayload

  createRef(input: CreateRefInput!): CreateRefPayload

  createRepository(input: CreateRepositoryInput!): CreateRepositoryPayload

  declineTopicSuggestion(input: DeclineTopicSuggestionInput!): DeclineTopicSuggestionPayload

  deleteBranchProtectionRule(input: DeleteBranchProtectionRuleInput!): DeleteBranchProtectionRulePayload

  deleteIssue(input: DeleteIssueInput!): DeleteIssuePayload

  deleteIssueComment(input: DeleteIssueCommentInput!): DeleteIssueCommentPayload

  deleteProject(input: DeleteProjectInput!): DeleteProjectPayload

  deleteProjectCard(input: DeleteProjectCardInput!): DeleteProjectCardPayload

  deleteProjectColumn(input: DeleteProjectColumnInput!): DeleteProjectColumnPayload

  deletePullRequestReview(input: DeletePullRequestReviewInput!): DeletePullRequestReviewPayload

  deletePullRequestReviewComment(input: DeletePullRequestReviewCommentInput!): DeletePullRequestReviewCommentPayload

  deleteRef(input: DeleteRefInput!): DeleteRefPayload

  dismissPullRequestReview(input: DismissPullRequestReviewInput!): DismissPullRequestReviewPayload

  linkRepositoryToProject(input: LinkRepositoryToProjectInput!): LinkRepositoryToProjectPayload

  lockLockable(input: LockLockableInput!): LockLockablePayload

  mergeBranch(input: MergeBranchInput!): MergeBranchPayload

  mergePullRequest(input: MergePullRequestInput!): MergePullRequestPayload

  moveProjectCard(input: MoveProjectCardInput!): MoveProjectCardPayload

  moveProjectColumn(input: MoveProjectColumnInput!): MoveProjectColumnPayload

  removeAssigneesFromAssignable(input: RemoveAssigneesFromAssignableInput!): RemoveAssigneesFromAssignablePayload

  removeLabelsFromLabelable(input: RemoveLabelsFromLabelableInput!): RemoveLabelsFromLabelablePayload

  removeOutsideCollaborator(input: RemoveOutsideCollaboratorInput!): RemoveOutsideCollaboratorPayload

  removeReaction(input: RemoveReactionInput!): RemoveReactionPayload

  removeStar(input: RemoveStarInput!): RemoveStarPayload

  reopenIssue(input: ReopenIssueInput!): ReopenIssuePayload

  reopenPullRequest(input: ReopenPullRequestInput!): ReopenPullRequestPayload

  requestReviews(input: RequestReviewsInput!): RequestReviewsPayload

  resolveReviewThread(input: ResolveReviewThreadInput!): ResolveReviewThreadPayload

  submitPullRequestReview(input: SubmitPullRequestReviewInput!): SubmitPullRequestReviewPayload

  unlinkRepositoryFromProject(input: UnlinkRepositoryFromProjectInput!): UnlinkRepositoryFromProjectPayload

  unlockLockable(input: UnlockLockableInput!): UnlockLockablePayload

  unmarkIssueAsDuplicate(input: UnmarkIssueAsDuplicateInput!): UnmarkIssueAsDuplicatePayload

  unresolveReviewThread(input: UnresolveReviewThreadInput!): UnresolveReviewThreadPayload

  updateBranchProtectionRule(input: UpdateBranchProtectionRuleInput!): UpdateBranchProtectionRulePayload

  updateIssue(input: UpdateIssueInput!): UpdateIssuePayload

  updateIssueComment(input: UpdateIssueCommentInput!): UpdateIssueCommentPayload

  updateProject(input: UpdateProjectInput!): UpdateProjectPayload

  updateProjectCard(input: UpdateProjectCardInput!): UpdateProjectCardPayload

  updateProjectColumn(input: UpdateProjectColumnInput!): UpdateProjectColumnPayload

  updatePullRequest(input: UpdatePullRequestInput!): UpdatePullRequestPayload

  updatePullRequestReview(input: UpdatePullRequestReviewInput!): UpdatePullRequestReviewPayload

  updatePullRequestReviewComment(input: UpdatePullRequestReviewCommentInput!): UpdatePullRequestReviewCommentPayload

  updateRef(input: UpdateRefInput!): UpdateRefPayload

  updateRepository(input: UpdateRepositoryInput!): UpdateRepositoryPayload

  updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscriptionPayload

  updateTopics(input: UpdateTopicsInput!): UpdateTopicsPayload
}

interface Node {
  id: ID!
}

enum OrderDirection {
  ASC

  DESC
}

type Organization implements Actor & MemberStatusable & Node & ProfileOwner & ProjectOwner & RegistryPackageOwner & RegistryPackageSearch & RepositoryOwner & UniformResourceLocatable {
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!

  avatarUrl(
    size: Int
  ): URI!

  databaseId: Int

  description: String

  email: String
  id: ID!

  isVerified: Boolean!

  itemShowcase: ProfileItemShowcase!

  location: String

  login: String!

  memberStatuses(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!

  membersWithRole(
    after: String

    before: String

    first: Int

    last: Int
  ): OrganizationMemberConnection!

  name: String

  newTeamResourcePath: URI!

  newTeamUrl: URI!

  organizationBillingEmail: String

  pendingMembers(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  pinnableItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItemsRemaining: Int!

  pinnedRepositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection! @deprecated(reason: "pinnedRepositories will be removed Use ProfileOwner.pinnedItems instead. Removal on 2019-10-01 UTC.")

  project(
    number: Int!
  ): Project

  projects(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]
  ): ProjectConnection!

  projectsResourcePath: URI!

  projectsUrl: URI!

  registryPackages(
    after: String

    before: String

    first: Int

    last: Int

    name: String

    names: [String]

    packageType: RegistryPackageType

    publicOnly: Boolean = false

    registryPackageType: String

    repositoryId: ID
  ): RegistryPackageConnection!

  registryPackagesForQuery(
    after: String

    before: String

    first: Int

    last: Int

    packageType: RegistryPackageType

    query: String
  ): RegistryPackageConnection!

  repositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isFork: Boolean

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  repository(
    name: String!
  ): Repository

  requiresTwoFactorAuthentication: Boolean

  resourcePath: URI!

  samlIdentityProvider: OrganizationIdentityProvider

  team(
    slug: String!
  ): Team

  teams(
    after: String

    before: String

    first: Int

    last: Int

    ldapMapped: Boolean

    orderBy: TeamOrder

    privacy: TeamPrivacy

    query: String

    role: TeamRole

    rootTeamsOnly: Boolean = false

    userLogins: [String!]
  ): TeamConnection!

  teamsResourcePath: URI!

  teamsUrl: URI!

  url: URI!

  viewerCanAdminister: Boolean!

  viewerCanChangePinnedItems: Boolean!

  viewerCanCreateProjects: Boolean!

  viewerCanCreateRepositories: Boolean!

  viewerCanCreateTeams: Boolean!

  viewerIsAMember: Boolean!

  websiteUrl: URI
}

type OrganizationConnection {
  edges: [OrganizationEdge]

  nodes: [Organization]

  pageInfo: PageInfo!

  totalCount: Int!
}

type OrganizationEdge {
  cursor: String!

  node: Organization
}

type OrganizationIdentityProvider implements Node {
  digestMethod: URI

  externalIdentities(
    after: String

    before: String

    first: Int

    last: Int
  ): ExternalIdentityConnection!
  id: ID!

  idpCertificate: X509Certificate

  issuer: String

  organization: Organization

  signatureMethod: URI

  ssoUrl: URI
}

type OrganizationInvitation implements Node {
  createdAt: DateTime!

  email: String
  id: ID!

  invitationType: OrganizationInvitationType!

  invitee: User

  inviter: User!

  organization: Organization!

  role: OrganizationInvitationRole!
}

type OrganizationInvitationConnection {
  edges: [OrganizationInvitationEdge]

  nodes: [OrganizationInvitation]

  pageInfo: PageInfo!

  totalCount: Int!
}

type OrganizationInvitationEdge {
  cursor: String!

  node: OrganizationInvitation
}

enum OrganizationInvitationRole {
  ADMIN

  BILLING_MANAGER

  DIRECT_MEMBER

  REINSTATE
}

enum OrganizationInvitationType {
  EMAIL

  USER
}

type OrganizationMemberConnection {
  edges: [OrganizationMemberEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type OrganizationMemberEdge {
  cursor: String!

  hasTwoFactorEnabled: Boolean

  node: User

  role: OrganizationMemberRole
}

enum OrganizationMemberRole {
  ADMIN

  MEMBER
}

type PageInfo {
  endCursor: String

  hasNextPage: Boolean!

  hasPreviousPage: Boolean!

  startCursor: String
}

union PermissionGranter = Organization | Repository | Team

type PermissionSource {
  organization: Organization!

  permission: DefaultRepositoryPermissionField!

  source: PermissionGranter!
}

input PinIssueInput {
  clientMutationId: String

  issueId: ID!
}

union PinnableItem = Gist | Repository

type PinnableItemConnection {
  edges: [PinnableItemEdge]

  nodes: [PinnableItem]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PinnableItemEdge {
  cursor: String!

  node: PinnableItem
}

enum PinnableItemType {
  GIST

  ISSUE

  ORGANIZATION

  PROJECT

  PULL_REQUEST

  REPOSITORY

  TEAM

  USER
}

type PinnedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  issue: Issue!
}

type ProfileItemShowcase {
  hasPinnedItems: Boolean!

  items(
    after: String

    before: String

    first: Int

    last: Int
  ): PinnableItemConnection!
}

interface ProfileOwner {
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!

  email: String
  id: ID!

  itemShowcase: ProfileItemShowcase!

  location: String

  login: String!

  name: String

  pinnableItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItemsRemaining: Int!

  viewerCanChangePinnedItems: Boolean!

  websiteUrl: URI
}

type Project implements Closable & Node & Updatable {
  body: String

  bodyHTML: HTML!

  closed: Boolean!

  closedAt: DateTime

  columns(
    after: String

    before: String

    first: Int

    last: Int
  ): ProjectColumnConnection!

  createdAt: DateTime!

  creator: Actor

  databaseId: Int
  id: ID!

  name: String!

  number: Int!

  owner: ProjectOwner!

  pendingCards(
    after: String

    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]

    before: String

    first: Int

    last: Int
  ): ProjectCardConnection!

  resourcePath: URI!

  state: ProjectState!

  updatedAt: DateTime!

  url: URI!

  viewerCanUpdate: Boolean!
}

type ProjectCard implements Node {
  column: ProjectColumn

  content: ProjectCardItem

  createdAt: DateTime!

  creator: Actor

  databaseId: Int
  id: ID!

  isArchived: Boolean!

  note: String

  project: Project!

  resourcePath: URI!

  state: ProjectCardState

  updatedAt: DateTime!

  url: URI!
}

enum ProjectCardArchivedState {
  ARCHIVED

  NOT_ARCHIVED
}

type ProjectCardConnection {
  edges: [ProjectCardEdge]

  nodes: [ProjectCard]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ProjectCardEdge {
  cursor: String!

  node: ProjectCard
}

input ProjectCardImport {
  number: Int!

  repository: String!
}

union ProjectCardItem = Issue | PullRequest

enum ProjectCardState {
  CONTENT_ONLY

  NOTE_ONLY

  REDACTED
}

type ProjectColumn implements Node {
  cards(
    after: String

    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]

    before: String

    first: Int

    last: Int
  ): ProjectCardConnection!

  createdAt: DateTime!

  databaseId: Int
  id: ID!

  name: String!

  project: Project!

  purpose: ProjectColumnPurpose

  resourcePath: URI!

  updatedAt: DateTime!

  url: URI!
}

type ProjectColumnConnection {
  edges: [ProjectColumnEdge]

  nodes: [ProjectColumn]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ProjectColumnEdge {
  cursor: String!

  node: ProjectColumn
}

input ProjectColumnImport {
  columnName: String!

  issues: [ProjectCardImport!]

  position: Int!
}

enum ProjectColumnPurpose {
  DONE

  IN_PROGRESS

  TODO
}

type ProjectConnection {
  edges: [ProjectEdge]

  nodes: [Project]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ProjectEdge {
  cursor: String!

  node: Project
}

input ProjectOrder {
  direction: OrderDirection!

  field: ProjectOrderField!
}

enum ProjectOrderField {
  CREATED_AT

  NAME

  UPDATED_AT
}

interface ProjectOwner {
  id: ID!

  project(
    number: Int!
  ): Project

  projects(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]
  ): ProjectConnection!

  projectsResourcePath: URI!

  projectsUrl: URI!

  viewerCanCreateProjects: Boolean!
}

enum ProjectState {
  CLOSED

  OPEN
}

enum ProjectTemplate {
  AUTOMATED_KANBAN_V2

  AUTOMATED_REVIEWS_KANBAN

  BASIC_KANBAN

  BUG_TRIAGE
}

type PublicKey implements Node {
  accessedAt: DateTime

  createdAt: DateTime

  fingerprint: String!
  id: ID!

  isReadOnly: Boolean

  key: String!

  updatedAt: DateTime
}

type PublicKeyConnection {
  edges: [PublicKeyEdge]

  nodes: [PublicKey]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PublicKeyEdge {
  cursor: String!

  node: PublicKey
}

type PullRequest implements Assignable & Closable & Comment & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason

  additions: Int!

  assignees(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  author: Actor

  authorAssociation: CommentAuthorAssociation!

  baseRef: Ref

  baseRefName: String!

  baseRefOid: GitObjectID!

  baseRepository: Repository

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  changedFiles: Int!

  closed: Boolean!

  closedAt: DateTime

  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): IssueCommentConnection!

  commits(
    after: String

    before: String

    first: Int

    last: Int
  ): PullRequestCommitConnection!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  deletions: Int!

  editor: Actor

  files(
    after: String

    before: String

    first: Int

    last: Int
  ): PullRequestChangedFileConnection

  headRef: Ref

  headRefName: String!

  headRefOid: GitObjectID!

  headRepository: Repository

  headRepositoryOwner: RepositoryOwner
  id: ID!

  includesCreatedEdit: Boolean!

  isCrossRepository: Boolean!

  labels(
    after: String

    before: String

    first: Int

    last: Int
  ): LabelConnection

  lastEditedAt: DateTime

  locked: Boolean!

  maintainerCanModify: Boolean!

  mergeCommit: Commit

  mergeable: MergeableState!

  merged: Boolean!

  mergedAt: DateTime

  mergedBy: Actor

  milestone: Milestone

  number: Int!

  participants(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  permalink: URI!

  potentialMergeCommit: Commit

  projectCards(
    after: String

    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]

    before: String

    first: Int

    last: Int
  ): ProjectCardConnection!

  publishedAt: DateTime

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  repository: Repository!

  resourcePath: URI!

  revertResourcePath: URI!

  revertUrl: URI!

  reviewRequests(
    after: String

    before: String

    first: Int

    last: Int
  ): ReviewRequestConnection

  reviewThreads(
    after: String

    before: String

    first: Int

    last: Int
  ): PullRequestReviewThreadConnection!

  reviews(
    after: String

    author: String

    before: String

    first: Int

    last: Int

    states: [PullRequestReviewState!]
  ): PullRequestReviewConnection

  state: PullRequestState!

  suggestedReviewers: [SuggestedReviewer]!

  timeline(
    after: String

    before: String

    first: Int

    last: Int

    since: DateTime
  ): PullRequestTimelineConnection! @deprecated(reason: "`timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2019-10-01 UTC.")

  timelineItems(
    after: String

    before: String

    first: Int

    itemTypes: [PullRequestTimelineItemsItemType!]

    last: Int

    since: DateTime

    skip: Int
  ): PullRequestTimelineItemsConnection!

  title: String!

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanApplySuggestion: Boolean!

  viewerCanReact: Boolean!

  viewerCanSubscribe: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!

  viewerSubscription: SubscriptionState
}

type PullRequestChangedFile {
  additions: Int!

  deletions: Int!

  path: String!
}

type PullRequestChangedFileConnection {
  edges: [PullRequestChangedFileEdge]

  nodes: [PullRequestChangedFile]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestChangedFileEdge {
  cursor: String!

  node: PullRequestChangedFile
}

type PullRequestCommit implements Node & UniformResourceLocatable {
  commit: Commit!
  id: ID!

  pullRequest: PullRequest!

  resourcePath: URI!

  url: URI!
}

type PullRequestCommitCommentThread implements Node & RepositoryNode {
  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitCommentConnection!

  commit: Commit!
  id: ID!

  path: String

  position: Int

  pullRequest: PullRequest!

  repository: Repository!
}

type PullRequestCommitConnection {
  edges: [PullRequestCommitEdge]

  nodes: [PullRequestCommit]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestCommitEdge {
  cursor: String!

  node: PullRequestCommit
}

type PullRequestConnection {
  edges: [PullRequestEdge]

  nodes: [PullRequest]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestContributionsByRepository {
  contributions(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedPullRequestContributionConnection!

  repository: Repository!
}

type PullRequestEdge {
  cursor: String!

  node: PullRequest
}

input PullRequestOrder {
  direction: OrderDirection!

  field: PullRequestOrderField!
}

enum PullRequestOrderField {
  CREATED_AT

  UPDATED_AT
}

enum PullRequestPubSubTopic {
  HEAD_REF

  MARKASREAD

  STATE

  TIMELINE

  UPDATED
}

type PullRequestReview implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): PullRequestReviewCommentConnection!

  commit: Commit

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  lastEditedAt: DateTime

  onBehalfOf(
    after: String

    before: String

    first: Int

    last: Int
  ): TeamConnection!

  publishedAt: DateTime

  pullRequest: PullRequest!

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  repository: Repository!

  resourcePath: URI!

  state: PullRequestReviewState!

  submittedAt: DateTime

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanDelete: Boolean!

  viewerCanReact: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!
}

type PullRequestReviewComment implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor

  authorAssociation: CommentAuthorAssociation!

  body: String!

  bodyHTML: HTML!

  bodyText: String!

  commit: Commit!

  createdAt: DateTime!

  createdViaEmail: Boolean!

  databaseId: Int

  diffHunk: String!

  draftedAt: DateTime!

  editor: Actor
  id: ID!

  includesCreatedEdit: Boolean!

  isMinimized: Boolean!

  lastEditedAt: DateTime

  minimizedReason: String

  originalCommit: Commit

  originalPosition: Int!

  outdated: Boolean!

  path: String!

  position: Int

  publishedAt: DateTime

  pullRequest: PullRequest!

  pullRequestReview: PullRequestReview

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  replyTo: PullRequestReviewComment

  repository: Repository!

  resourcePath: URI!

  state: PullRequestReviewCommentState!

  updatedAt: DateTime!

  url: URI!

  userContentEdits(
    after: String

    before: String

    first: Int

    last: Int
  ): UserContentEditConnection

  viewerCanDelete: Boolean!

  viewerCanMinimize: Boolean!

  viewerCanReact: Boolean!

  viewerCanUpdate: Boolean!

  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!

  viewerDidAuthor: Boolean!
}

type PullRequestReviewCommentConnection {
  edges: [PullRequestReviewCommentEdge]

  nodes: [PullRequestReviewComment]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestReviewCommentEdge {
  cursor: String!

  node: PullRequestReviewComment
}

enum PullRequestReviewCommentState {
  PENDING

  SUBMITTED
}

type PullRequestReviewConnection {
  edges: [PullRequestReviewEdge]

  nodes: [PullRequestReview]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestReviewContributionsByRepository {
  contributions(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!

  repository: Repository!
}

type PullRequestReviewEdge {
  cursor: String!

  node: PullRequestReview
}

enum PullRequestReviewEvent {
  APPROVE

  COMMENT

  DISMISS

  REQUEST_CHANGES
}

enum PullRequestReviewState {
  APPROVED

  CHANGES_REQUESTED

  COMMENTED

  DISMISSED

  PENDING
}

type PullRequestReviewThread implements Node {
  comments(
    after: String

    before: String

    first: Int

    last: Int
  ): PullRequestReviewCommentConnection!
  id: ID!

  isResolved: Boolean!

  pullRequest: PullRequest!

  repository: Repository!

  resolvedBy: User

  viewerCanResolve: Boolean!

  viewerCanUnresolve: Boolean!
}

type PullRequestReviewThreadConnection {
  edges: [PullRequestReviewThreadEdge]

  nodes: [PullRequestReviewThread]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PullRequestReviewThreadEdge {
  cursor: String!

  node: PullRequestReviewThread
}

type PullRequestRevisionMarker {
  createdAt: DateTime!

  lastSeenCommit: Commit!

  pullRequest: PullRequest!
}

enum PullRequestState {
  CLOSED

  MERGED

  OPEN
}

type PullRequestTimelineConnection {
  edges: [PullRequestTimelineItemEdge]

  nodes: [PullRequestTimelineItem]

  pageInfo: PageInfo!

  totalCount: Int!
}

union PullRequestTimelineItem = AssignedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent

type PullRequestTimelineItemEdge {
  cursor: String!

  node: PullRequestTimelineItem
}

union PullRequestTimelineItems = AddedToProjectEvent | AssignedEvent | BaseRefChangedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConvertedNoteToIssueEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent

type PullRequestTimelineItemsConnection {
  edges: [PullRequestTimelineItemsEdge]

  filteredCount: Int!

  nodes: [PullRequestTimelineItems]

  pageCount: Int!

  pageInfo: PageInfo!

  totalCount: Int!

  updatedAt: DateTime!
}

type PullRequestTimelineItemsEdge {
  cursor: String!

  node: PullRequestTimelineItems
}

enum PullRequestTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT

  ASSIGNED_EVENT

  BASE_REF_CHANGED_EVENT

  BASE_REF_FORCE_PUSHED_EVENT

  CLOSED_EVENT

  COMMENT_DELETED_EVENT

  CONVERTED_NOTE_TO_ISSUE_EVENT

  CROSS_REFERENCED_EVENT

  DEMILESTONED_EVENT

  DEPLOYED_EVENT

  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT

  HEAD_REF_DELETED_EVENT

  HEAD_REF_FORCE_PUSHED_EVENT

  HEAD_REF_RESTORED_EVENT

  ISSUE_COMMENT

  LABELED_EVENT

  LOCKED_EVENT

  MARKED_AS_DUPLICATE_EVENT

  MENTIONED_EVENT

  MERGED_EVENT

  MILESTONED_EVENT

  MOVED_COLUMNS_IN_PROJECT_EVENT

  PINNED_EVENT

  PULL_REQUEST_COMMIT

  PULL_REQUEST_COMMIT_COMMENT_THREAD

  PULL_REQUEST_REVIEW

  PULL_REQUEST_REVIEW_THREAD

  PULL_REQUEST_REVISION_MARKER

  READY_FOR_REVIEW_EVENT

  REFERENCED_EVENT

  REMOVED_FROM_PROJECT_EVENT

  RENAMED_TITLE_EVENT

  REOPENED_EVENT

  REVIEW_DISMISSED_EVENT

  REVIEW_REQUESTED_EVENT

  REVIEW_REQUEST_REMOVED_EVENT

  SUBSCRIBED_EVENT

  TRANSFERRED_EVENT

  UNASSIGNED_EVENT

  UNLABELED_EVENT

  UNLOCKED_EVENT

  UNPINNED_EVENT

  UNSUBSCRIBED_EVENT

  USER_BLOCKED_EVENT
}

type PushAllowance implements Node {
  actor: PushAllowanceActor

  branchProtectionRule: BranchProtectionRule
  id: ID!
}

union PushAllowanceActor = Team | User

type PushAllowanceConnection {
  edges: [PushAllowanceEdge]

  nodes: [PushAllowance]

  pageInfo: PageInfo!

  totalCount: Int!
}

type PushAllowanceEdge {
  cursor: String!

  node: PushAllowance
}

type Query {
  codeOfConduct(
    key: String!
  ): CodeOfConduct

  codesOfConduct: [CodeOfConduct]

  license(
    key: String!
  ): License

  licenses: [License]!

  marketplaceCategories(
    excludeEmpty: Boolean

    excludeSubcategories: Boolean

    includeCategories: [String!]
  ): [MarketplaceCategory!]!

  marketplaceCategory(
    slug: String!

    useTopicAliases: Boolean
  ): MarketplaceCategory

  marketplaceListing(
    slug: String!
  ): MarketplaceListing

  marketplaceListings(
    adminId: ID

    after: String

    allStates: Boolean

    before: String

    categorySlug: String

    first: Int

    last: Int

    organizationId: ID

    primaryCategoryOnly: Boolean = false

    slugs: [String]

    useTopicAliases: Boolean

    viewerCanAdmin: Boolean

    withFreeTrialsOnly: Boolean = false
  ): MarketplaceListingConnection!

  meta: GitHubMetadata!

  node(
    id: ID!
  ): Node

  nodes(
    ids: [ID!]!
  ): [Node]!

  organization(
    login: String!
  ): Organization

  rateLimit(
    dryRun: Boolean = false
  ): RateLimit

  relay: Query!

  repository(
    name: String!

    owner: String!
  ): Repository

  repositoryOwner(
    login: String!
  ): RepositoryOwner

  resource(
    url: URI!
  ): UniformResourceLocatable

  search(
    after: String

    before: String

    first: Int

    last: Int

    query: String!

    type: SearchType!
  ): SearchResultItemConnection!

  securityAdvisories(
    after: String

    before: String

    first: Int

    identifier: SecurityAdvisoryIdentifierFilter

    last: Int

    orderBy: SecurityAdvisoryOrder = {field: UPDATED_AT, direction: DESC}

    publishedSince: DateTime

    updatedSince: DateTime
  ): SecurityAdvisoryConnection!

  securityAdvisory(
    ghsaId: String!
  ): SecurityAdvisory

  securityVulnerabilities(
    after: String

    before: String

    ecosystem: SecurityAdvisoryEcosystem

    first: Int

    last: Int

    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}

    package: String

    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!

  sponsorsListing(
    slug: String!
  ): SponsorsListing

  topic(
    name: String!
  ): Topic

  user(
    login: String!
  ): User

  viewer: User!
}

type RateLimit {
  cost: Int!

  limit: Int!

  nodeCount: Int!

  remaining: Int!

  resetAt: DateTime!
}

interface Reactable {
  databaseId: Int
  id: ID!

  reactionGroups: [ReactionGroup!]

  reactions(
    after: String

    before: String

    content: ReactionContent

    first: Int

    last: Int

    orderBy: ReactionOrder
  ): ReactionConnection!

  viewerCanReact: Boolean!
}

type ReactingUserConnection {
  edges: [ReactingUserEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ReactingUserEdge {
  cursor: String!
  node: User!

  reactedAt: DateTime!
}

type Reaction implements Node {
  content: ReactionContent!

  createdAt: DateTime!

  databaseId: Int
  id: ID!

  reactable: Reactable!

  user: User
}

type ReactionConnection {
  edges: [ReactionEdge]

  nodes: [Reaction]

  pageInfo: PageInfo!

  totalCount: Int!

  viewerHasReacted: Boolean!
}

enum ReactionContent {
  CONFUSED

  EYES

  HEART

  HOORAY

  LAUGH

  ROCKET

  THUMBS_DOWN

  THUMBS_UP
}

type ReactionEdge {
  cursor: String!

  node: Reaction
}

type ReactionGroup {
  content: ReactionContent!

  createdAt: DateTime

  subject: Reactable!

  users(
    after: String

    before: String

    first: Int

    last: Int
  ): ReactingUserConnection!

  viewerHasReacted: Boolean!
}

input ReactionOrder {
  direction: OrderDirection!

  field: ReactionOrderField!
}

enum ReactionOrderField {
  CREATED_AT
}

type ReadyForReviewEvent implements Node & UniformResourceLocatable {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!

  resourcePath: URI!

  url: URI!
}

type Ref implements Node {
  associatedPullRequests(
    after: String

    baseRefName: String

    before: String

    first: Int

    headRefName: String

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [PullRequestState!]
  ): PullRequestConnection!
  id: ID!

  name: String!

  prefix: String!

  repository: Repository!

  target: GitObject!
}

type RefConnection {
  edges: [RefEdge]

  nodes: [Ref]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RefEdge {
  cursor: String!

  node: Ref
}

input RefOrder {
  direction: OrderDirection!

  field: RefOrderField!
}

enum RefOrderField {
  ALPHABETICAL

  TAG_COMMIT_DATE
}

type ReferencedEvent implements Node {
  actor: Actor

  commit: Commit

  commitRepository: Repository!

  createdAt: DateTime!
  id: ID!

  isCrossRepository: Boolean!

  isDirectReference: Boolean!

  subject: ReferencedSubject!
}

union ReferencedSubject = Issue | PullRequest

type RegistryPackage implements Node {
  color: String!
  id: ID!

  latestVersion: RegistryPackageVersion

  name: String!

  nameWithOwner: String!

  packageFileByGuid(
    guid: String!
  ): RegistryPackageFile

  packageFileBySha256(
    sha256: String!
  ): RegistryPackageFile

  packageType: RegistryPackageType!

  preReleaseVersions(
    after: String

    before: String

    first: Int

    last: Int
  ): RegistryPackageVersionConnection

  registryPackageType: String

  repository: Repository

  statistics: RegistryPackageStatistics

  tags(
    after: String

    before: String

    first: Int

    last: Int
  ): RegistryPackageTagConnection!

  topics(
    after: String

    before: String

    first: Int

    last: Int
  ): TopicConnection

  version(
    version: String!
  ): RegistryPackageVersion

  versionByPlatform(
    platform: String!

    version: String!
  ): RegistryPackageVersion

  versionBySha256(
    sha256: String!
  ): RegistryPackageVersion

  versions(
    after: String

    before: String

    first: Int

    last: Int
  ): RegistryPackageVersionConnection!

  versionsByMetadatum(
    after: String

    before: String

    first: Int

    last: Int

    metadatum: RegistryPackageMetadatum!
  ): RegistryPackageVersionConnection
}

type RegistryPackageConnection {
  edges: [RegistryPackageEdge]

  nodes: [RegistryPackage]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RegistryPackageDependency implements Node {
  dependencyType: RegistryPackageDependencyType!
  id: ID!

  name: String!

  version: String!
}

type RegistryPackageDependencyConnection {
  edges: [RegistryPackageDependencyEdge]

  nodes: [RegistryPackageDependency]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RegistryPackageDependencyEdge {
  cursor: String!

  node: RegistryPackageDependency
}

enum RegistryPackageDependencyType {
  BUNDLED

  DEFAULT

  DEV

  OPTIONAL

  PEER

  TEST
}

type RegistryPackageEdge {
  cursor: String!

  node: RegistryPackage
}

type RegistryPackageFile implements Node {
  guid: String
  id: ID!

  md5: String

  metadataUrl: URI!

  name: String!

  packageVersion: RegistryPackageVersion!

  sha1: String

  sha256: String

  size: Int

  updatedAt: DateTime!

  url: URI!
}

type RegistryPackageFileConnection {
  edges: [RegistryPackageFileEdge]

  nodes: [RegistryPackageFile]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RegistryPackageFileEdge {
  cursor: String!

  node: RegistryPackageFile
}

enum RegistryPackageFileState {
  NEW

  UPLOADED
}

input RegistryPackageMetadatum {
  name: String!

  update: Boolean

  value: String!
}

interface RegistryPackageOwner {
  id: ID!

  registryPackages(
    after: String

    before: String

    first: Int

    last: Int

    name: String

    names: [String]

    packageType: RegistryPackageType

    publicOnly: Boolean = false

    registryPackageType: String

    repositoryId: ID
  ): RegistryPackageConnection!
}

interface RegistryPackageSearch {
  id: ID!

  registryPackagesForQuery(
    after: String

    before: String

    first: Int

    last: Int

    packageType: RegistryPackageType

    query: String
  ): RegistryPackageConnection!
}

type RegistryPackageStatistics {
  downloadsThisMonth: Int!

  downloadsThisWeek: Int!

  downloadsThisYear: Int!

  downloadsToday: Int!

  downloadsTotalCount: Int!
}

type RegistryPackageTag implements Node {
  id: ID!

  name: String!

  version: RegistryPackageVersion
}

type RegistryPackageTagConnection {
  edges: [RegistryPackageTagEdge]

  nodes: [RegistryPackageTag]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RegistryPackageTagEdge {
  cursor: String!

  node: RegistryPackageTag
}

enum RegistryPackageType {
  DEBIAN

  DOCKER

  MAVEN

  NPM

  NUGET

  PYTHON

  RUBYGEMS
}

type RegistryPackageVersion implements Node {
  dependencies(
    after: String

    before: String

    first: Int

    last: Int

    type: RegistryPackageDependencyType
  ): RegistryPackageDependencyConnection!

  fileByName(
    filename: String!
  ): RegistryPackageFile

  files(
    after: String

    before: String

    first: Int

    last: Int
  ): RegistryPackageFileConnection!
  id: ID!

  installationCommand: String

  manifest: String

  platform: String

  readme: String

  readmeHtml: HTML

  registryPackage: RegistryPackage

  release: Release

  sha256: String

  size: Int

  statistics: RegistryPackageVersionStatistics

  summary: String

  updatedAt: DateTime!

  version: String!

  viewerCanEdit: Boolean!
}

type RegistryPackageVersionConnection {
  edges: [RegistryPackageVersionEdge]

  nodes: [RegistryPackageVersion]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RegistryPackageVersionEdge {
  cursor: String!

  node: RegistryPackageVersion
}

type RegistryPackageVersionStatistics {
  downloadsThisMonth: Int!

  downloadsThisWeek: Int!

  downloadsThisYear: Int!

  downloadsToday: Int!

  downloadsTotalCount: Int!
}

type Release implements Node & UniformResourceLocatable {
  author: User

  createdAt: DateTime!

  description: String
  id: ID!

  isDraft: Boolean!

  isPrerelease: Boolean!

  name: String

  publishedAt: DateTime

  releaseAssets(
    after: String

    before: String

    first: Int

    last: Int

    name: String
  ): ReleaseAssetConnection!

  resourcePath: URI!

  tag: Ref

  tagName: String!

  updatedAt: DateTime!

  url: URI!
}

type ReleaseAsset implements Node {
  contentType: String!

  createdAt: DateTime!

  downloadCount: Int!

  downloadUrl: URI!
  id: ID!

  name: String!

  release: Release

  size: Int!

  updatedAt: DateTime!

  uploadedBy: User!

  url: URI!
}

type ReleaseAssetConnection {
  edges: [ReleaseAssetEdge]

  nodes: [ReleaseAsset]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ReleaseAssetEdge {
  cursor: String!

  node: ReleaseAsset
}

type ReleaseConnection {
  edges: [ReleaseEdge]

  nodes: [Release]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ReleaseEdge {
  cursor: String!

  node: Release
}

input ReleaseOrder {
  direction: OrderDirection!

  field: ReleaseOrderField!
}

enum ReleaseOrderField {
  CREATED_AT

  NAME
}

input RemoveAssigneesFromAssignableInput {
  assignableId: ID!

  assigneeIds: [ID!]!

  clientMutationId: String
}

type RemoveAssigneesFromAssignablePayload {
  assignable: Assignable

  clientMutationId: String
}

input RemoveLabelsFromLabelableInput {
  clientMutationId: String

  labelIds: [ID!]!

  labelableId: ID!
}

type RemoveLabelsFromLabelablePayload {
  clientMutationId: String

  labelable: Labelable
}

input RemoveOutsideCollaboratorInput {
  clientMutationId: String

  organizationId: ID!

  userId: ID!
}

type RemoveOutsideCollaboratorPayload {
  clientMutationId: String

  removedUser: User
}

input RemoveReactionInput {
  clientMutationId: String

  content: ReactionContent!

  subjectId: ID!
}

type RemoveReactionPayload {
  clientMutationId: String

  reaction: Reaction

  subject: Reactable
}

input RemoveStarInput {
  clientMutationId: String

  starrableId: ID!
}

type RemoveStarPayload {
  clientMutationId: String

  starrable: Starrable
}

type RemovedFromProjectEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int
  id: ID!
}

type RenamedTitleEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  currentTitle: String!
  id: ID!

  previousTitle: String!

  subject: RenamedTitleSubject!
}

union RenamedTitleSubject = Issue | PullRequest

input ReopenIssueInput {
  clientMutationId: String

  issueId: ID!
}

type ReopenIssuePayload {
  clientMutationId: String

  issue: Issue
}

input ReopenPullRequestInput {
  clientMutationId: String

  pullRequestId: ID!
}

type ReopenPullRequestPayload {
  clientMutationId: String

  pullRequest: PullRequest
}

type ReopenedEvent implements Node {
  actor: Actor

  closable: Closable!

  createdAt: DateTime!
  id: ID!
}

enum ReportedContentClassifiers {
  ABUSE

  OFF_TOPIC

  OUTDATED

  RESOLVED

  SPAM
}

type Repository implements Node & ProjectOwner & RegistryPackageOwner & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable {
  assignableUsers(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  branchProtectionRules(
    after: String

    before: String

    first: Int

    last: Int
  ): BranchProtectionRuleConnection!

  codeOfConduct: CodeOfConduct

  collaborators(
    affiliation: CollaboratorAffiliation

    after: String

    before: String

    first: Int

    last: Int
  ): RepositoryCollaboratorConnection

  commitComments(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitCommentConnection!

  createdAt: DateTime!

  databaseId: Int

  defaultBranchRef: Ref

  deployKeys(
    after: String

    before: String

    first: Int

    last: Int
  ): DeployKeyConnection!

  deployments(
    after: String

    before: String

    environments: [String!]

    first: Int

    last: Int

    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection!

  description: String

  descriptionHTML: HTML!

  diskUsage: Int

  forkCount: Int!

  forks(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  hasIssuesEnabled: Boolean!

  hasWikiEnabled: Boolean!

  homepageUrl: URI
  id: ID!

  isArchived: Boolean!

  isDisabled: Boolean!

  isFork: Boolean!

  isLocked: Boolean!

  isMirror: Boolean!

  isPrivate: Boolean!

  isTemplate: Boolean!

  issue(
    number: Int!
  ): Issue

  issueOrPullRequest(
    number: Int!
  ): IssueOrPullRequest

  issues(
    after: String

    before: String

    filterBy: IssueFilters

    first: Int

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [IssueState!]
  ): IssueConnection!

  label(
    name: String!
  ): Label

  labels(
    after: String

    before: String

    first: Int

    last: Int

    query: String
  ): LabelConnection

  languages(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: LanguageOrder
  ): LanguageConnection

  licenseInfo: License

  lockReason: RepositoryLockReason

  mentionableUsers(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!

  mergeCommitAllowed: Boolean!

  milestone(
    number: Int!
  ): Milestone

  milestones(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: MilestoneOrder

    states: [MilestoneState!]
  ): MilestoneConnection

  mirrorUrl: URI

  name: String!

  nameWithOwner: String!

  object(
    expression: String

    oid: GitObjectID
  ): GitObject

  openGraphImageUrl: URI!

  owner: RepositoryOwner!

  parent: Repository

  primaryLanguage: Language

  project(
    number: Int!
  ): Project

  projects(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]
  ): ProjectConnection!

  projectsResourcePath: URI!

  projectsUrl: URI!

  pullRequest(
    number: Int!
  ): PullRequest

  pullRequests(
    after: String

    baseRefName: String

    before: String

    first: Int

    headRefName: String

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [PullRequestState!]
  ): PullRequestConnection!

  pushedAt: DateTime

  rebaseMergeAllowed: Boolean!

  ref(
    qualifiedName: String!
  ): Ref

  refs(
    after: String

    before: String

    direction: OrderDirection

    first: Int

    last: Int

    orderBy: RefOrder

    refPrefix: String!
  ): RefConnection

  registryPackages(
    after: String

    before: String

    first: Int

    last: Int

    name: String

    names: [String]

    packageType: RegistryPackageType

    publicOnly: Boolean = false

    registryPackageType: String

    repositoryId: ID
  ): RegistryPackageConnection!

  release(
    tagName: String!
  ): Release

  releases(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ReleaseOrder
  ): ReleaseConnection!

  repositoryTopics(
    after: String

    before: String

    first: Int

    last: Int
  ): RepositoryTopicConnection!

  resourcePath: URI!

  shortDescriptionHTML(
    limit: Int = 200
  ): HTML!

  squashMergeAllowed: Boolean!

  sshUrl: GitSSHRemote!

  stargazers(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: StarOrder
  ): StargazerConnection!

  templateRepository: Repository

  updatedAt: DateTime!

  url: URI!

  usesCustomOpenGraphImage: Boolean!

  viewerCanAdminister: Boolean!

  viewerCanCreateProjects: Boolean!

  viewerCanSubscribe: Boolean!

  viewerCanUpdateTopics: Boolean!

  viewerHasStarred: Boolean!

  viewerPermission: RepositoryPermission

  viewerSubscription: SubscriptionState

  watchers(
    after: String

    before: String

    first: Int

    last: Int
  ): UserConnection!
}

enum RepositoryAffiliation {
  COLLABORATOR

  ORGANIZATION_MEMBER

  OWNER
}

enum RepositoryCollaboratorAffiliation {
  ALL

  OUTSIDE
}

type RepositoryCollaboratorConnection {
  edges: [RepositoryCollaboratorEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RepositoryCollaboratorEdge {
  cursor: String!
  node: User!

  permission: RepositoryPermission!

  permissionSources: [PermissionSource!]
}

type RepositoryConnection {
  edges: [RepositoryEdge]

  nodes: [Repository]

  pageInfo: PageInfo!

  totalCount: Int!

  totalDiskUsage: Int!
}

enum RepositoryContributionType {
  COMMIT

  ISSUE

  PULL_REQUEST

  PULL_REQUEST_REVIEW

  REPOSITORY
}

type RepositoryEdge {
  cursor: String!

  node: Repository
}

interface RepositoryInfo {
  createdAt: DateTime!

  description: String

  descriptionHTML: HTML!

  forkCount: Int!

  hasIssuesEnabled: Boolean!

  hasWikiEnabled: Boolean!

  homepageUrl: URI

  isArchived: Boolean!

  isFork: Boolean!

  isLocked: Boolean!

  isMirror: Boolean!

  isPrivate: Boolean!

  isTemplate: Boolean!

  licenseInfo: License

  lockReason: RepositoryLockReason

  mirrorUrl: URI

  name: String!

  nameWithOwner: String!

  openGraphImageUrl: URI!

  owner: RepositoryOwner!

  pushedAt: DateTime

  resourcePath: URI!

  shortDescriptionHTML(
    limit: Int = 200
  ): HTML!

  updatedAt: DateTime!

  url: URI!

  usesCustomOpenGraphImage: Boolean!
}

type RepositoryInvitation implements Node {
  id: ID!

  invitee: User!

  inviter: User!

  permission: RepositoryPermission!

  repository: RepositoryInfo
}

type RepositoryInvitationEdge {
  cursor: String!

  node: RepositoryInvitation
}

enum RepositoryLockReason {
  BILLING

  MIGRATING

  MOVING

  RENAME
}

interface RepositoryNode {
  repository: Repository!
}

input RepositoryOrder {
  direction: OrderDirection!

  field: RepositoryOrderField!
}

enum RepositoryOrderField {
  CREATED_AT

  NAME

  PUSHED_AT

  STARGAZERS

  UPDATED_AT
}

interface RepositoryOwner {
  avatarUrl(
    size: Int
  ): URI!
  id: ID!

  login: String!

  pinnedRepositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection! @deprecated(reason: "pinnedRepositories will be removed Use ProfileOwner.pinnedItems instead. Removal on 2019-10-01 UTC.")

  repositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isFork: Boolean

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  repository(
    name: String!
  ): Repository

  resourcePath: URI!

  url: URI!
}

enum RepositoryPermission {
  ADMIN

  MAINTAIN

  READ

  TRIAGE

  WRITE
}

enum RepositoryPrivacy {
  PRIVATE

  PUBLIC
}

type RepositoryTopic implements Node & UniformResourceLocatable {
  id: ID!

  resourcePath: URI!

  topic: Topic!

  url: URI!
}

type RepositoryTopicConnection {
  edges: [RepositoryTopicEdge]

  nodes: [RepositoryTopic]

  pageInfo: PageInfo!

  totalCount: Int!
}

type RepositoryTopicEdge {
  cursor: String!

  node: RepositoryTopic
}

enum RepositoryVisibility {
  INTERNAL

  PRIVATE

  PUBLIC
}

input RequestReviewsInput {
  clientMutationId: String

  pullRequestId: ID!

  teamIds: [ID!]

  union: Boolean

  userIds: [ID!]
}

type RequestReviewsPayload {
  clientMutationId: String

  pullRequest: PullRequest

  requestedReviewersEdge: UserEdge
}

union RequestedReviewer = Mannequin | Team | User

input ResolveReviewThreadInput {
  clientMutationId: String

  threadId: ID!
}

type ResolveReviewThreadPayload {
  clientMutationId: String

  thread: PullRequestReviewThread
}

type RestrictedContribution implements Contribution {
  isRestricted: Boolean!

  occurredAt: DateTime!

  resourcePath: URI!

  url: URI!

  user: User!
}

type ReviewDismissalAllowance implements Node {
  actor: ReviewDismissalAllowanceActor

  branchProtectionRule: BranchProtectionRule
  id: ID!
}

union ReviewDismissalAllowanceActor = Team | User

type ReviewDismissalAllowanceConnection {
  edges: [ReviewDismissalAllowanceEdge]

  nodes: [ReviewDismissalAllowance]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ReviewDismissalAllowanceEdge {
  cursor: String!

  node: ReviewDismissalAllowance
}

type ReviewDismissedEvent implements Node & UniformResourceLocatable {
  actor: Actor

  createdAt: DateTime!

  databaseId: Int

  dismissalMessage: String

  dismissalMessageHTML: String
  id: ID!

  previousReviewState: PullRequestReviewState!

  pullRequest: PullRequest!

  pullRequestCommit: PullRequestCommit

  resourcePath: URI!

  review: PullRequestReview

  url: URI!
}

type ReviewRequest implements Node {
  databaseId: Int
  id: ID!

  pullRequest: PullRequest!

  requestedReviewer: RequestedReviewer
}

type ReviewRequestConnection {
  edges: [ReviewRequestEdge]

  nodes: [ReviewRequest]

  pageInfo: PageInfo!

  totalCount: Int!
}

type ReviewRequestEdge {
  cursor: String!

  node: ReviewRequest
}

type ReviewRequestRemovedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!

  requestedReviewer: RequestedReviewer
}

type ReviewRequestedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  pullRequest: PullRequest!

  requestedReviewer: RequestedReviewer
}

type SavedReply implements Node {
  body: String!

  bodyHTML: HTML!

  databaseId: Int
  id: ID!

  title: String!

  user: Actor
}

type SavedReplyConnection {
  edges: [SavedReplyEdge]

  nodes: [SavedReply]

  pageInfo: PageInfo!

  totalCount: Int!
}

type SavedReplyEdge {
  cursor: String!

  node: SavedReply
}

input SavedReplyOrder {
  direction: OrderDirection!

  field: SavedReplyOrderField!
}

enum SavedReplyOrderField {
  UPDATED_AT
}

union SearchResultItem = App | Issue | MarketplaceListing | Organization | PullRequest | Repository | User

type SearchResultItemConnection {
  codeCount: Int!

  edges: [SearchResultItemEdge]

  issueCount: Int!

  nodes: [SearchResultItem]

  pageInfo: PageInfo!

  repositoryCount: Int!

  userCount: Int!

  wikiCount: Int!
}

type SearchResultItemEdge {
  cursor: String!

  node: SearchResultItem

  textMatches: [TextMatch]
}

enum SearchType {
  ISSUE

  REPOSITORY

  USER
}

type SecurityAdvisory implements Node {
  databaseId: Int

  description: String!

  ghsaId: String!
  id: ID!

  identifiers: [SecurityAdvisoryIdentifier!]!

  origin: String!

  publishedAt: DateTime!

  references: [SecurityAdvisoryReference!]!

  severity: SecurityAdvisorySeverity!

  summary: String!

  updatedAt: DateTime!

  vulnerabilities(
    after: String

    before: String

    ecosystem: SecurityAdvisoryEcosystem

    first: Int

    last: Int

    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}

    package: String

    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!

  withdrawnAt: DateTime
}

type SecurityAdvisoryConnection {
  edges: [SecurityAdvisoryEdge]

  nodes: [SecurityAdvisory]

  pageInfo: PageInfo!

  totalCount: Int!
}

enum SecurityAdvisoryEcosystem {
  MAVEN

  NPM

  NUGET

  PIP

  RUBYGEMS
}

type SecurityAdvisoryEdge {
  cursor: String!

  node: SecurityAdvisory
}

type SecurityAdvisoryIdentifier {
  type: String!

  value: String!
}

input SecurityAdvisoryIdentifierFilter {
  type: SecurityAdvisoryIdentifierType!

  value: String!
}

enum SecurityAdvisoryIdentifierType {
  CVE

  GHSA
}

input SecurityAdvisoryOrder {
  direction: OrderDirection!

  field: SecurityAdvisoryOrderField!
}

enum SecurityAdvisoryOrderField {
  PUBLISHED_AT

  UPDATED_AT
}

type SecurityAdvisoryPackage {
  ecosystem: SecurityAdvisoryEcosystem!

  name: String!
}

type SecurityAdvisoryPackageVersion {
  identifier: String!
}

type SecurityAdvisoryReference {
  url: URI!
}

enum SecurityAdvisorySeverity {
  CRITICAL

  HIGH

  LOW

  MODERATE
}

type SecurityVulnerability {
  advisory: SecurityAdvisory!

  firstPatchedVersion: SecurityAdvisoryPackageVersion

  package: SecurityAdvisoryPackage!

  severity: SecurityAdvisorySeverity!

  updatedAt: DateTime!

  vulnerableVersionRange: String!
}

type SecurityVulnerabilityConnection {
  edges: [SecurityVulnerabilityEdge]

  nodes: [SecurityVulnerability]

  pageInfo: PageInfo!

  totalCount: Int!
}

type SecurityVulnerabilityEdge {
  cursor: String!

  node: SecurityVulnerability
}

input SecurityVulnerabilityOrder {
  direction: OrderDirection!

  field: SecurityVulnerabilityOrderField!
}

enum SecurityVulnerabilityOrderField {
  UPDATED_AT
}

type SmimeSignature implements GitSignature {
  email: String!

  isValid: Boolean!

  payload: String!

  signature: String!

  signer: User

  state: GitSignatureState!

  wasSignedByGitHub: Boolean!
}

interface Sponsorable {
  sponsorshipsAsMaintainer(
    after: String

    before: String

    first: Int

    includePrivate: Boolean = false

    last: Int

    orderBy: SponsorshipOrder
  ): SponsorshipConnection!

  sponsorshipsAsSponsor(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
}

type SponsorsListing implements Node {
  fullDescription: String!
  id: ID!

  shortDescription: String!

  slug: String!
}

type Sponsorship implements Node {
  createdAt: DateTime!
  id: ID!

  maintainer: User!

  privacyLevel: SponsorshipPrivacy!

  sponsor: User
}

type SponsorshipConnection {
  edges: [SponsorshipEdge]

  nodes: [Sponsorship]

  pageInfo: PageInfo!

  totalCount: Int!
}

type SponsorshipEdge {
  cursor: String!

  node: Sponsorship
}

input SponsorshipOrder {
  direction: OrderDirection!
}

enum SponsorshipPrivacy {
  PRIVATE

  PUBLIC
}

input StarOrder {
  direction: OrderDirection!

  field: StarOrderField!
}

enum StarOrderField {
  STARRED_AT
}

type StargazerConnection {
  edges: [StargazerEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type StargazerEdge {
  cursor: String!
  node: User!

  starredAt: DateTime!
}

interface Starrable {
  id: ID!

  stargazers(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: StarOrder
  ): StargazerConnection!

  viewerHasStarred: Boolean!
}

type StarredRepositoryConnection {
  edges: [StarredRepositoryEdge]

  nodes: [Repository]

  pageInfo: PageInfo!

  totalCount: Int!
}

type StarredRepositoryEdge {
  cursor: String!
  node: Repository!

  starredAt: DateTime!
}

type Status implements Node {
  commit: Commit

  context(
    name: String!
  ): StatusContext

  contexts: [StatusContext!]!
  id: ID!

  state: StatusState!
}

type StatusContext implements Node {
  avatarUrl(
    size: Int = 40
  ): URI

  commit: Commit

  context: String!

  createdAt: DateTime!

  creator: Actor

  description: String
  id: ID!

  state: StatusState!

  targetUrl: URI
}

enum StatusState {
  ERROR

  EXPECTED

  FAILURE

  PENDING

  SUCCESS
}

input SubmitPullRequestReviewInput {
  body: String

  clientMutationId: String

  event: PullRequestReviewEvent!

  pullRequestReviewId: ID!
}

type SubmitPullRequestReviewPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview
}

interface Subscribable {
  id: ID!

  viewerCanSubscribe: Boolean!

  viewerSubscription: SubscriptionState
}

type SubscribedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  subscribable: Subscribable!
}

enum SubscriptionState {
  IGNORED

  SUBSCRIBED

  UNSUBSCRIBED
}

type SuggestedReviewer {
  isAuthor: Boolean!

  isCommenter: Boolean!

  reviewer: User!
}

type Tag implements GitObject & Node {
  abbreviatedOid: String!

  commitResourcePath: URI!

  commitUrl: URI!
  id: ID!

  message: String

  name: String!

  oid: GitObjectID!

  repository: Repository!

  tagger: GitActor

  target: GitObject!
}

type Team implements MemberStatusable & Node & Subscribable {
  ancestors(
    after: String

    before: String

    first: Int

    last: Int
  ): TeamConnection!

  avatarUrl(
    size: Int = 400
  ): URI

  childTeams(
    after: String

    before: String

    first: Int

    immediateOnly: Boolean = true

    last: Int

    orderBy: TeamOrder

    userLogins: [String!]
  ): TeamConnection!

  combinedSlug: String!

  createdAt: DateTime!

  description: String

  editTeamResourcePath: URI!

  editTeamUrl: URI!
  id: ID!

  invitations(
    after: String

    before: String

    first: Int

    last: Int
  ): OrganizationInvitationConnection

  memberStatuses(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!

  members(
    after: String

    before: String

    first: Int

    last: Int

    membership: TeamMembershipType = ALL

    orderBy: TeamMemberOrder

    query: String

    role: TeamMemberRole
  ): TeamMemberConnection!

  membersResourcePath: URI!

  membersUrl: URI!

  name: String!

  newTeamResourcePath: URI!

  newTeamUrl: URI!

  organization: Organization!

  parentTeam: Team

  privacy: TeamPrivacy!

  repositories(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: TeamRepositoryOrder

    query: String
  ): TeamRepositoryConnection!

  repositoriesResourcePath: URI!

  repositoriesUrl: URI!

  resourcePath: URI!

  slug: String!

  teamsResourcePath: URI!

  teamsUrl: URI!

  updatedAt: DateTime!

  url: URI!

  viewerCanAdminister: Boolean!

  viewerCanSubscribe: Boolean!

  viewerSubscription: SubscriptionState
}

type TeamConnection {
  edges: [TeamEdge]

  nodes: [Team]

  pageInfo: PageInfo!

  totalCount: Int!
}

type TeamEdge {
  cursor: String!

  node: Team
}

type TeamMemberConnection {
  edges: [TeamMemberEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type TeamMemberEdge {
  cursor: String!

  memberAccessResourcePath: URI!

  memberAccessUrl: URI!
  node: User!

  role: TeamMemberRole!
}

input TeamMemberOrder {
  direction: OrderDirection!

  field: TeamMemberOrderField!
}

enum TeamMemberOrderField {
  CREATED_AT

  LOGIN
}

enum TeamMemberRole {
  MAINTAINER

  MEMBER
}

enum TeamMembershipType {
  ALL

  CHILD_TEAM

  IMMEDIATE
}

input TeamOrder {
  direction: OrderDirection!

  field: TeamOrderField!
}

enum TeamOrderField {
  NAME
}

enum TeamPrivacy {
  SECRET

  VISIBLE
}

type TeamRepositoryConnection {
  edges: [TeamRepositoryEdge]

  nodes: [Repository]

  pageInfo: PageInfo!

  totalCount: Int!
}

type TeamRepositoryEdge {
  cursor: String!
  node: Repository!

  permission: RepositoryPermission!
}

input TeamRepositoryOrder {
  direction: OrderDirection!

  field: TeamRepositoryOrderField!
}

enum TeamRepositoryOrderField {
  CREATED_AT

  NAME

  PERMISSION

  PUSHED_AT

  STARGAZERS

  UPDATED_AT
}

enum TeamRole {
  ADMIN

  MEMBER
}

type TextMatch {
  fragment: String!

  highlights: [TextMatchHighlight!]!

  property: String!
}

type TextMatchHighlight {
  beginIndice: Int!

  endIndice: Int!

  text: String!
}

type Topic implements Node & Starrable {
  id: ID!

  name: String!

  relatedTopics(
    first: Int = 3
  ): [Topic!]!

  stargazers(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: StarOrder
  ): StargazerConnection!

  viewerHasStarred: Boolean!
}

type TopicConnection {
  edges: [TopicEdge]

  nodes: [Topic]

  pageInfo: PageInfo!

  totalCount: Int!
}

type TopicEdge {
  cursor: String!

  node: Topic
}

enum TopicSuggestionDeclineReason {
  NOT_RELEVANT

  PERSONAL_PREFERENCE

  TOO_GENERAL

  TOO_SPECIFIC
}

type TransferredEvent implements Node {
  actor: Actor

  createdAt: DateTime!

  fromRepository: Repository
  id: ID!

  issue: Issue!
}

type Tree implements GitObject & Node {
  abbreviatedOid: String!

  commitResourcePath: URI!

  commitUrl: URI!

  entries: [TreeEntry!]
  id: ID!

  oid: GitObjectID!

  repository: Repository!
}

type TreeEntry {
  mode: Int!

  name: String!

  object: GitObject

  oid: GitObjectID!

  repository: Repository!

  type: String!
}

scalar URI

type UnassignedEvent implements Node {
  actor: Actor

  assignable: Assignable!

  assignee: Assignee

  createdAt: DateTime!
  id: ID!

  user: User @deprecated(reason: "Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.")
}

interface UniformResourceLocatable {
  resourcePath: URI!

  url: URI!
}

type UnknownSignature implements GitSignature {
  email: String!

  isValid: Boolean!

  payload: String!

  signature: String!

  signer: User

  state: GitSignatureState!

  wasSignedByGitHub: Boolean!
}

type UnlabeledEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  label: Label!

  labelable: Labelable!
}

input UnlinkRepositoryFromProjectInput {
  clientMutationId: String

  projectId: ID!

  repositoryId: ID!
}

type UnlinkRepositoryFromProjectPayload {
  clientMutationId: String

  project: Project

  repository: Repository
}

input UnlockLockableInput {
  clientMutationId: String

  lockableId: ID!
}

type UnlockLockablePayload {
  clientMutationId: String

  unlockedRecord: Lockable
}

type UnlockedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  lockable: Lockable!
}

input UnmarkIssueAsDuplicateInput {
  canonicalId: ID!

  clientMutationId: String

  duplicateId: ID!
}

type UnmarkIssueAsDuplicatePayload {
  clientMutationId: String

  duplicate: IssueOrPullRequest
}

input UnminimizeCommentInput {
  clientMutationId: String

  subjectId: ID!
}

input UnpinIssueInput {
  clientMutationId: String

  issueId: ID!
}

type UnpinnedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  issue: Issue!
}

input UnresolveReviewThreadInput {
  clientMutationId: String

  threadId: ID!
}

type UnresolveReviewThreadPayload {
  clientMutationId: String

  thread: PullRequestReviewThread
}

type UnsubscribedEvent implements Node {
  actor: Actor

  createdAt: DateTime!
  id: ID!

  subscribable: Subscribable!
}

interface Updatable {
  viewerCanUpdate: Boolean!
}

interface UpdatableComment {
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
}

input UpdateBranchProtectionRuleInput {
  branchProtectionRuleId: ID!

  clientMutationId: String

  dismissesStaleReviews: Boolean

  isAdminEnforced: Boolean

  pattern: String

  pushActorIds: [ID!]

  requiredApprovingReviewCount: Int

  requiredStatusCheckContexts: [String!]

  requiresApprovingReviews: Boolean

  requiresCodeOwnerReviews: Boolean

  requiresCommitSignatures: Boolean

  requiresStatusChecks: Boolean

  requiresStrictStatusChecks: Boolean

  restrictsPushes: Boolean

  restrictsReviewDismissals: Boolean

  reviewDismissalActorIds: [ID!]
}

type UpdateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule

  clientMutationId: String
}

input UpdateIssueCommentInput {
  body: String!

  clientMutationId: String

  id: ID!
}

type UpdateIssueCommentPayload {
  clientMutationId: String

  issueComment: IssueComment
}

input UpdateIssueInput {
  assigneeIds: [ID!]

  body: String

  clientMutationId: String

  id: ID!

  labelIds: [ID!]

  milestoneId: ID

  projectIds: [ID!]

  state: IssueState

  title: String
}

type UpdateIssuePayload {
  clientMutationId: String

  issue: Issue
}

input UpdateProjectCardInput {
  clientMutationId: String

  isArchived: Boolean

  note: String

  projectCardId: ID!
}

type UpdateProjectCardPayload {
  clientMutationId: String

  projectCard: ProjectCard
}

input UpdateProjectColumnInput {
  clientMutationId: String

  name: String!

  projectColumnId: ID!
}

type UpdateProjectColumnPayload {
  clientMutationId: String

  projectColumn: ProjectColumn
}

input UpdateProjectInput {
  body: String

  clientMutationId: String

  name: String

  projectId: ID!

  public: Boolean

  state: ProjectState
}

type UpdateProjectPayload {
  clientMutationId: String

  project: Project
}

input UpdatePullRequestInput {
  baseRefName: String

  body: String

  clientMutationId: String

  maintainerCanModify: Boolean

  pullRequestId: ID!

  title: String
}

type UpdatePullRequestPayload {
  clientMutationId: String

  pullRequest: PullRequest
}

input UpdatePullRequestReviewCommentInput {
  body: String!

  clientMutationId: String

  pullRequestReviewCommentId: ID!
}

type UpdatePullRequestReviewCommentPayload {
  clientMutationId: String

  pullRequestReviewComment: PullRequestReviewComment
}

input UpdatePullRequestReviewInput {
  body: String!

  clientMutationId: String

  pullRequestReviewId: ID!
}

type UpdatePullRequestReviewPayload {
  clientMutationId: String

  pullRequestReview: PullRequestReview
}

input UpdateRefInput {
  clientMutationId: String

  force: Boolean = false

  oid: GitObjectID!

  refId: ID!
}

type UpdateRefPayload {
  clientMutationId: String

  ref: Ref
}

input UpdateRepositoryInput {
  clientMutationId: String

  description: String

  hasIssuesEnabled: Boolean

  hasProjectsEnabled: Boolean

  hasWikiEnabled: Boolean

  homepageUrl: URI

  name: String

  repositoryId: ID!

  template: Boolean
}

type UpdateRepositoryPayload {
  clientMutationId: String

  repository: Repository
}

input UpdateSubscriptionInput {
  clientMutationId: String

  state: SubscriptionState!

  subscribableId: ID!
}

type UpdateSubscriptionPayload {
  clientMutationId: String

  subscribable: Subscribable
}

input UpdateTopicsInput {
  clientMutationId: String

  repositoryId: ID!

  topicNames: [String!]!
}

type UpdateTopicsPayload {
  clientMutationId: String

  invalidTopicNames: [String!]

  repository: Repository
}

type User implements Actor & Node & ProfileOwner & ProjectOwner & RegistryPackageOwner & RegistryPackageSearch & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!

  avatarUrl(
    size: Int
  ): URI!

  bio: String

  bioHTML: HTML!

  commitComments(
    after: String

    before: String

    first: Int

    last: Int
  ): CommitCommentConnection!

  company: String

  companyHTML: HTML!

  contributionsCollection(
    from: DateTime

    organizationID: ID

    to: DateTime
  ): ContributionsCollection!

  createdAt: DateTime!

  databaseId: Int

  email: String!

  followers(
    after: String

    before: String

    first: Int

    last: Int
  ): FollowerConnection!

  following(
    after: String

    before: String

    first: Int

    last: Int
  ): FollowingConnection!

  gist(
    name: String!
  ): Gist

  gistComments(
    after: String

    before: String

    first: Int

    last: Int
  ): GistCommentConnection!

  gists(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: GistOrder

    privacy: GistPrivacy
  ): GistConnection!
  id: ID!

  isBountyHunter: Boolean!

  isCampusExpert: Boolean!

  isDeveloperProgramMember: Boolean!

  isEmployee: Boolean!

  isHireable: Boolean!

  isSiteAdmin: Boolean!

  isViewer: Boolean!

  issueComments(
    after: String

    before: String

    first: Int

    last: Int
  ): IssueCommentConnection!

  issues(
    after: String

    before: String

    filterBy: IssueFilters

    first: Int

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [IssueState!]
  ): IssueConnection!

  itemShowcase: ProfileItemShowcase!

  location: String

  login: String!

  name: String

  organization(
    login: String!
  ): Organization

  organizations(
    after: String

    before: String

    first: Int

    last: Int
  ): OrganizationConnection!

  pinnableItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItems(
    after: String

    before: String

    first: Int

    last: Int

    types: [PinnableItemType!]
  ): PinnableItemConnection!

  pinnedItemsRemaining: Int!

  pinnedRepositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection! @deprecated(reason: "pinnedRepositories will be removed Use ProfileOwner.pinnedItems instead. Removal on 2019-10-01 UTC.")

  project(
    number: Int!
  ): Project

  projects(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: ProjectOrder

    search: String

    states: [ProjectState!]
  ): ProjectConnection!

  projectsResourcePath: URI!

  projectsUrl: URI!

  publicKeys(
    after: String

    before: String

    first: Int

    last: Int
  ): PublicKeyConnection!

  pullRequests(
    after: String

    baseRefName: String

    before: String

    first: Int

    headRefName: String

    labels: [String!]

    last: Int

    orderBy: IssueOrder

    states: [PullRequestState!]
  ): PullRequestConnection!

  registryPackages(
    after: String

    before: String

    first: Int

    last: Int

    name: String

    names: [String]

    packageType: RegistryPackageType

    publicOnly: Boolean = false

    registryPackageType: String

    repositoryId: ID
  ): RegistryPackageConnection!

  registryPackagesForQuery(
    after: String

    before: String

    first: Int

    last: Int

    packageType: RegistryPackageType

    query: String
  ): RegistryPackageConnection!

  repositories(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    after: String

    before: String

    first: Int

    isFork: Boolean

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  repositoriesContributedTo(
    after: String

    before: String

    contributionTypes: [RepositoryContributionType]

    first: Int

    includeUserRepositories: Boolean

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  repository(
    name: String!
  ): Repository

  resourcePath: URI!

  savedReplies(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: SavedReplyOrder = {field: UPDATED_AT, direction: DESC}
  ): SavedReplyConnection

  sponsorshipsAsMaintainer(
    after: String

    before: String

    first: Int

    includePrivate: Boolean = false

    last: Int

    orderBy: SponsorshipOrder
  ): SponsorshipConnection!

  sponsorshipsAsSponsor(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: SponsorshipOrder
  ): SponsorshipConnection!

  starredRepositories(
    after: String

    before: String

    first: Int

    last: Int

    orderBy: StarOrder

    ownedByViewer: Boolean
  ): StarredRepositoryConnection!

  status: UserStatus

  updatedAt: DateTime!

  url: URI!

  viewerCanChangePinnedItems: Boolean!

  viewerCanCreateProjects: Boolean!

  viewerCanFollow: Boolean!

  viewerIsFollowing: Boolean!

  watching(
    affiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR, ORGANIZATION_MEMBER]

    after: String

    before: String

    first: Int

    isLocked: Boolean

    last: Int

    orderBy: RepositoryOrder

    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]

    privacy: RepositoryPrivacy
  ): RepositoryConnection!

  websiteUrl: URI
}

enum UserBlockDuration {
  ONE_DAY

  ONE_MONTH

  ONE_WEEK

  PERMANENT

  THREE_DAYS
}

type UserBlockedEvent implements Node {
  actor: Actor

  blockDuration: UserBlockDuration!

  createdAt: DateTime!
  id: ID!

  subject: User
}

type UserConnection {
  edges: [UserEdge]

  nodes: [User]

  pageInfo: PageInfo!

  totalCount: Int!
}

type UserContentEdit implements Node {
  createdAt: DateTime!

  deletedAt: DateTime

  deletedBy: Actor

  diff: String

  editedAt: DateTime!

  editor: Actor
  id: ID!

  updatedAt: DateTime!
}

type UserContentEditConnection {
  edges: [UserContentEditEdge]

  nodes: [UserContentEdit]

  pageInfo: PageInfo!

  totalCount: Int!
}

type UserContentEditEdge {
  cursor: String!

  node: UserContentEdit
}

type UserEdge {
  cursor: String!

  node: User
}

type UserStatus implements Node {
  createdAt: DateTime!

  emoji: String

  emojiHTML: HTML

  expiresAt: DateTime

  id: ID!

  indicatesLimitedAvailability: Boolean!

  message: String

  organization: Organization

  updatedAt: DateTime!

  user: User!
}

type UserStatusConnection {
  edges: [UserStatusEdge]

  nodes: [UserStatus]

  pageInfo: PageInfo!

  totalCount: Int!
}

type UserStatusEdge {
  cursor: String!

  node: UserStatus
}

input UserStatusOrder {
  direction: OrderDirection!

  field: UserStatusOrderField!
}

enum UserStatusOrderField {
  UPDATED_AT
}

scalar X509Certificate